<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXC8C71ED5C77B420EB0EE2DE358CA78BB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">DataStoreV5</string>
			<int64 name="SourceAssetId">17528018574</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX331E447697634159AD0AECC09378ABF6">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX0ACF40C5FD324F99984B8019B715EF36">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DataStoreManager</string>
					<string name="ScriptGuid">{B1D2C2D6-3B7B-4B3D-A260-CE77929E7C2D}</string>
					<ProtectedString name="Source"><![CDATA[export type DataStoreManager<TKey, TData> = typeof(
    setmetatable(
        {}:: {
            dataStore: DataStoreService,
            Name: string,
            PlayersData: any
        },
        {}:: {
            __index: {
                GetAsync: (self: Profile<TKey, TData>, player: Player,folder: string? ,attributeOption: 'Folder'?) -> Player,
                UpdateAsync: (self: Profile<TKey, TData>, player: Player, OnShutDown: boolean) -> boolean,
                OnLeave: (self: Profile<TKey, TData>, player: Player) -> Player,
                BindClose: (self: Profile<TKey, TData>, RunService: RunService, Players: Players) -> BindableEvent
            }
        }
    ))

local DataStoreV5 = {
    GetAsync = function(self ,player, folder, attributeOption)
        if self.Option == 'Value' then
            local Data
            local success, err = pcall(function()
                Data = self.PlayerStore:GetAsync(tostring(player.UserId))
            end)
            if not success then
                player:Kick(`Your Data didn't reload correctly please retry in a few minutes`)
            else
                local result = string.format('[%s]', player.Name)
                warn(result, 'Your Data was successfully restored')
            end
            if not Data then
                Data = self.CloneData(self.profile)
            else
                for info, data in pairs(self.profile) do
                    if Data[info] == nil then
                        Data[info] = data
                        for name, tab in pairs(data) do
                            if Data[info][name] == nil then
                                Data[info][name] = tab
                                for key, value in pairs(tab) do
                                    if Data[info][name][key] == nil then
                                        Data[info][name][key] = value
                                    end
                                end
                            end
                        end
                    end
                end
            end
            for info, data in pairs(Data) do
                if type(data) == 'table' then
                    for k, v in pairs(data) do
                        if self.profile[info][k] == nil then
                            data[k] = nil
                        end
                        if type(data) == 'table' then
                            for key, value in pairs(data) do
                                if self.profile[info][k][key] == nil then
                                    data[k][key] = nil
                                end
                            end
                        end
                    end
                else
                    if self.profile[info] == nil then
                        Data[info] = nil
                    end
                end
            end
            local UserData = self.SessionData.Session
            UserData[player.UserId] = Data
            self:CreateDataValues(UserData[player.UserId], player)
        elseif self.Option == 'Attribute' then
            local Data
            local success, err = pcall(function()
                Data = self.PlayerStore:GetAsync(tostring(player.UserId))
            end)
            if not success then
                player:Kick(`Your Data didn't reload correctly please retry in a few minutes`)
            else
                local result = string.format('[%s]', player.Name)
                warn(result, 'Your Data was successfully restored')
            end
            if not Data then
                Data = self.CloneData(self.profile)
            else
                for info, data in pairs(self.profile) do
                    if type(data) == 'table' then
                        for k, v in pairs(data) do
                            if Data[info][k] == nil then
                                Data[info][k] = v
                            end
                        end
                    else
                        if Data[info] == nil then
                            Data[info] = data
                        end
                    end
                end
            end
            for info, data in pairs(Data) do
                if type(data) == 'table' then
                    for k, v in pairs(data) do
                        if self.profile[info][k] == nil then
                            data[k] = nil
                        end
                    end
                else
                    if self.profile[info] == nil then
                        Data[info] = nil
                    end
                end
            end
            local UserData = self.SessionData.Session
            UserData[player.UserId] = Data
            if attributeOption then
                local fold = Instance.new('Folder')
                fold.Parent = player
                fold.Name = folder
                self:CreateDataAttFolder(UserData[player.UserId], player, fold)
            else
                self:CreateDataAttribute(UserData[player.UserId], player)
            end
            for info, data in pairs(UserData[player.UserId]) do
                for key, _ in pairs(data) do
                    local RemoteFunc = game:GetService('ReplicatedStorage'):FindFirstChild(key)
                    RemoteFunc:InvokeClient(player, player:GetAttribute(key))
                end
            end
        elseif self.Option == 'Table' then
            local Data
            local success, err = pcall(function()
                Data = self.PlayerStore:GetAsync(tostring(player.UserId))
            end)
            if not success then
                player:Kick(`Your Data didn't reload correctly please retry in a few minutes`)
            else
                local result = string.format('[%s]', player.Name)
                warn(result, 'Your Data was successfully restored')
            end
            if not Data then
                Data = self.CloneData(self.profile)
            else
                for info, data in pairs(self.profile) do
                    if type(data) == 'table' and Data[info] == nil then
                        Data[info] = data
                    end
                end
            end
            for info, data in pairs(Data) do
                if self.profile[info] == nil then
                    Data[info] = nil
                end
            end
            local UserData = self.SessionData.Session
            UserData[player.UserId] = Data
        elseif self.Option == 'ValueAttribute' then
            local Data
            local success, err = pcall(function()
                Data = self.PlayerStore:GetAsync(tostring(player.UserId))
            end)
            if not success then
                player:Kick(`Your Data didn't reload correctly please retry in a few minutes`)
            else
                local result = string.format('[%s]', player.Name)
                warn(result, 'Your Data was successfully restored')
            end
            if not Data then
                Data = self.CloneData(self.profile)
                print(Data)
            else
                for info, data in pairs(self.profile) do
                    if Data[info] == nil then
                        Data[info] = data
                    else
                        for name, tab in pairs(data) do
                            if Data[info][name] == nil then
                                Data[info][name] = tab
                            else
                                for key, value in pairs(tab) do
                                    if Data[info][name][key] == nil then
                                        Data[info][name][key] = value
                                    else
                                        if type(value) == 'table' then
                                            for subKey, subValue in pairs(value) do
                                                if Data[info][name][key][subKey] == nil then
                                                    Data[info][name][key][subKey] = subValue
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            for info, data in pairs(Data) do
                if type(data) == 'table' then
                    for k, v in pairs(data) do
                        if self.profile[info] and self.profile[info][k] == nil then
                            data[k] = nil
                        elseif type(v) == 'table' then
                            for key, value in pairs(v) do
                                if self.profile[info] and self.profile[info][k] and self.profile[info][k][key] == nil then
                                    data[k][key] = nil
                                elseif type(value) == 'table' then
                                    for sub, val in pairs(value) do
                                        if self.profile[info][k][key][sub] == nil then
                                            data[k][key][sub] = nil
                                        end
                                    end
                                end
                            end
                        end
                    end
                else
                    if self.profile[info] == nil then
                        Data[info] = nil
                    end
                end
            end

            local UserData = self.SessionData.Session
            UserData[player.UserId] = Data
            self:CreateDataValueAttribute(UserData[player.UserId], player)
        else
            warn(`Must have an Option for the CreateDataStore(Option) option1: Value, option2: Attribute, option3: Table or option4: ValueAttribute`)
        end
    end,
    BindClose = function(self, RunService, Players)
        if RunService:IsStudio() then task.wait(2) return end
        local AllPlayersSave = Instance.new('BindableEvent')
        local AllPlayers = Players:GetPlayers()
        local Remaining = #AllPlayers
        for index, player in pairs(AllPlayers) do
            task.spawn(function()
                self:UpdateAsync(player, true)
                Remaining -= 1
                if Remaining < 1 then AllPlayersSave:Fire() end
            end)
        end
        AllPlayersSave.Event:Wait()
    end,
    UpdateAsync = function(self, player, OnShutDown)
        local Session = self:GetData(player)
        local success, err
        repeat
            if not OnShutDown then self:GetRequest(Enum.DataStoreRequestType.UpdateAsync) end
            success, err= pcall(function()
                self.PlayerStore:UpdateAsync(tostring(player.UserId), function(oldData)
                    return Session
                end)
            end)
        until success
        if not success then
            print(`Players Data was not able to save`)
        else
            local result = string.format('[%s]', player.Name)
            warn(result, 'Your Data was successfully saved')
        end
        return true
    end,
    OnLeave = function(self, player)
        self:UpdateAsync(player)
        self.SessionData.Session[player.UserId] = nil
        return true
    end,
}
DataStoreV5.__index = DataStoreV5
DataStoreV5.__class = 'DataStore'

function DataStoreV5.CreateDataStore<TKey, TData>(DataStore, Name, PlayersData, Option: 'Value'|'Attribute'|'Table'|'ValueAttribute'): DataStoreManager<TKey, TData>
    local self = {
        DataStoreService = DataStore,
        PlayerStore = DataStore:GetDataStore(Name),
        profile = PlayersData,
        Option = Option,
        SessionData = require(script.Parent.Session)
    }
    setmetatable(self, DataStoreV5)
    self.CloneData = function(original)
        local clone = {}
        for info, data in pairs(original) do
            if type(data) == 'table' then
                clone[info] = self.CloneData(data)
            else
                clone[info] = data
            end
        end
        return clone
    end
    return self
end

function DataStoreV5:CreateDataValues(session, player)
    for info, data in pairs(session) do
        local Folder = Instance.new('Folder')
        Folder.Name = info
        Folder.Parent = player
        for subinfo, subdata in pairs(data) do
            if type(subdata) == 'table' then
                for key, value in pairs(subdata) do
                    local Val = Instance.new(subinfo)
                    Val.Name = key
                    Val.Value = value
                    Val.Parent = Folder
                end
            end
        end
    end
end

function DataStoreV5:CreateDataValueAttribute(session, player)
    for info, data in pairs(session) do
        local Folder = Instance.new('Folder')
        Folder.Name = info
        Folder.Parent = player
        for subinfo, subdata in pairs(data) do
            if type(subdata) == 'table' then
                for key, value in pairs(subdata) do
                    local Val = Instance.new(subinfo)
                    Val.Name = key
                    Val.Parent = Folder
                    for subInfo, subData in pairs(value) do
                        Val:SetAttribute(subInfo, subData)
                        if subInfo == 'MainValue' then
                            Val.Value = subData
                        end
                    end
                end
            end
        end
    end
end

function DataStoreV5:CreateDataAttribute(session, player: Player)
    for info, data in pairs(session) do
        if type(data) == 'table' then
            for subInfo, subData in pairs(data) do
                player:SetAttribute(subInfo, subData)
            end
        end
    end
end

function DataStoreV5:CreateDataAttFolder(session, player: Player, folder)
    for info, data in pairs(session) do
        if type(data) == 'table' then
            for subInfo, subData in pairs(data) do
                folder:SetAttribute(subInfo, subData)
            end
        end
    end
end

function DataStoreV5:GetRequest(Budget)
    local current = self.DataStoreService:GetRequestBudgetForRequestType(Budget)
    while current < 1 do
        task.wait(5)
        current = self.DataStoreService:GetRequestBudgetForRequestType(Budget)
    end
end

function DataStoreV5:GetData(player: Player)
    local Session = self.SessionData.Session[player.UserId]
    if not Session then return end
    return Session
end

function DataStoreV5:AutoSave(player:Players)
    while task.wait(30) do
        for _, players in pairs(player:GetPlayers()) do
            self:UpdateAsync(players)
        end
    end
end

return DataStoreV5]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXD38D1B22E2494049B2A6A7E7AE2D613C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Library</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX8DC6D1E7C2FE425FBC75ACEB31D69458">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">EternityNum</string>
						<string name="ScriptGuid">{ABB8023E-9E66-46A8-952C-98AB40248D3D}</string>
						<ProtectedString name="Source"><![CDATA[-- Made by FoundForces - CommanderSalty#2800

--// Config
local expl = 1e10 -- exponent limit
local ldown = math.log10(expl) -- val for layer down
local msd = 100 -- max sig digits
local AllowOverflow = true -- if this is true functions like to scientific will go to some other short function if input too large
local SuffixLimit = "9e1E14" -- Value when short() doesnt return suffix anymore
local DefaultDigits = 2 -- Amount of digits on short functions (-1 is all digits)
--


--[[
EN: A valid EternityNum Table
val: Any valid input that can be converted to an EternityNum Table

FUNCTIONS:
--// CHECK
	EN.IsNan(EN): boolean -> returns if the given value is NAN or not
	EN.IsInf(EN): boolean -> returns if the given value is INF or not
	EN.IsZero(EN): boolean -> returns if the given value is 0 or not

--// CONVERT
	EN.new(Sign, Layer, Exp): EN -> Directy create a new EternityNum Table :->: Sign * (10^^Layer)^Exp
	EN.fromNumber(number): EN -> Converts a number into an EternityNum Table
	EN.fromString(string): EN -> Converts a string into an EternityNum T able
	EN.fromScientific(string): EN -> Converts "XeY" into an EternityNum Table
	EN.fromDefaultStringFormat(string): EN -> Converts "X;Y" into an EternityNum Table
	EN.convert(val): EN -> Converts any valid input to an EternityNum Table
	
	EN.toNumber(EN): number -> Converts a EternityNum Table to an number
	EN.toString(EN): string -> Converts a EternityNum Table to an string ("X;Y")
	EN.toScientific(val): string -> Converts a value to an string ("XeY")
	EN.toLayerNotation(val, digits): string -> Converts a value to an string ("E(x)y")
	EN.toSuffix(val): string -> Converts a value to an suffix
	EN.short(val, digits): string -> Converts a value to an displayable string

--// BOOLEAN
	EN.eq(val1, val2): bool -> returns if val1 equals val2 (==)
	EN.le(val1, val2): bool -> returns if val1 is less then val2 (<)
	EN.me(val1, val2): bool -> returns if val1 is more then val2 (>)
	EN.leeq(val1, val2): bool -> returns if val1 is less or equal then val2 (<=)
	EN.meeq(val1, val2): bool -> returns if val1 is more or equal then val2 (>=)
	EN.bewteen(val, min, max): bool -> returns if val is between min and max

--// S CALCS
	EN.abs(val): EN -> returns the absolute value of val
	EN.neg(val): EN -> returns the negated value of val (-val)
	EN.recip(val): EN -> returns the reciprocal of val (1/val)
	EN.log10(val): EN -> returns the logarithm base 10 of val
	EN.abslog10(val): EN -> returns the logarithm base 10 of the absolute value of val :->: log10(abs(val))
	EN.exp(val): EN -> returns e^val 
    EN.pow10(val): EN -> returns 10^val
    EN.sqrt(val): EN -> returns the square root of val
    EN.gamma(val): EN -> returns (val - 1)!
    EN.fact(val): EN -> returns val!
    EN.correct(EN): EN -> error corrects an eternitynum (INTERNAL ONLY)
    
    --// USE FOR LEADERBOARDS
    EN.lbencode(val): number -> returns a number that can be stored in ordereddatastore
    EN.lbdecode(number): EN -> converts a lbecoded number back to an EternityNum Table
  
--// BIN CALCS
	EN.add(val1, val2): EN -> returns val1 + val2
	EN.sub(val1, val2): EN -> returns val1 - val2
	EN.mul(val1, val2): EN -> returns val1 * val2
	EN.div(val1, val2): EN -> returns val1 / val2
	EN.pow(val1, val2): EN -> returns val1 ^ val2
	EN.log(val, base): EN -> returns logarithm of val, if base is nil it will return log(val) (natural logarithm)
	EN.root(val1, val2): EN -> returns val2'th root of val1
	EN.rand(min, max): EN -> returns a random number between min and max
	EN.exporand(min, max): EN -> returns a random number between min and max
	EN.cmp(val1, val2): number -> 
		returns 0 if val1 == val2
		returns 1 if val1 > val2
		returns -1 if val1 < val2
	EN.cmpAbs(EN1, EN2): number -> returns cmp(abs(EN1),abs(EN2))
	EN.maxAbs(val1, val2): EN -> returns the max(abs(val1), abs(val2))
	
-- TO ADD:
	EN.min(val1, val2)
	EN.max(val1m val2)
]]

-----------
local C = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7}

function F_Gamma(n) : number -- (x-1)!
	if n > 171.6236 then return 1.8e308 end --// Point where Gamma(x) will return INF

	if (n > 0.5) then 
		n -= 1
		local x = C[1]

		for i=1, 7 do
			x += C[i + 1] / (n + i)
		end

		local t = n + 7.5
		return  x * t ^ (n + 0.5 - 36) * math.exp(-t) * t ^ 36 * 2.50662827463100050241576528
	end

	return 3.141592653589793238 / (math.sin(3.141592653589793238 * n) * F_Gamma(1 - n))
end
-----------



--// Constants
local tau = 6.2831853071795864769252842  --2*pi
local EXPN1 = 0.36787944117144232159553  --exp(-1)
local OMEGA = 0.56714329040978387299997  --W(1, 0)

function f_Lambertw(z) -- Lambertw function

	local tol = 1e-10
	local w, wn = nil

	if z > 1.79e308 then return z end
	if z == 0 then return z end
	if z == 1 then return OMEGA end

	if z < 10 then
		w = 0
	else
		w = math.log(z)-math.log(math.log(z))
	end

	for i=1, 100 do
		wn = (z * math.exp(-w) + w * w) / (w + 1)
		if math.abs(wn - w) < tol * math.abs(wn) then
			return wn
		else
			w = wn
		end
	end

	error('Failed to itterate z.... at function: f_lambertw')
end







--// Start of EternityNum
----------------------------------------------------------------------------------------------------------------
type EN = {Sign : number, Layer : number, Exp : number}
type BN = {Mantissa : number, Exp : number}
local EN = {}
-----------


function Cnew(Sign: number, Layer: number, Exp: number) : EN
	return {Sign=Sign, Layer=Layer, Exp=Exp}	
end

local ZERO: EN = Cnew(0, 0, 0)
local ONE: EN = Cnew(1, 0, 1)
local NaN: EN = Cnew(1, -1, 1)
local Inf: EN = Cnew(1, math.huge, 1)

local DefaultReturn = ZERO

function EN.IsNaN(Value: EN) : boolean
	return Value.Sign == NaN.Sign and Value.Layer == NaN.Layer and Value.Exp == NaN.Exp 
end

function EN.IsInf(Value: EN) : boolean
	return Value.Layer == math.huge or Value.Exp == math.huge 
end

function EN.IsZero(Value: EN) : boolean
	return Value.Sign == 0 or (Value.Exp == 0 and Value.Layer == 0)
end

function EN.correct(EtNum: EN): EN --// Corrects a EtNum
	if EN.IsNaN(EtNum) then return NaN end
	if EN.IsInf(EtNum) then return Inf end
	if EN.IsZero(EtNum) then return ZERO end
	local Sign = EtNum.Sign
	local Layers = EtNum.Layer
	local Exp = EtNum.Exp


	if Layers == 0 and Exp < 0 then
		Exp =- Exp
		Sign =- Sign
	end

	if Layers == 0 and Exp < 1e-10 then
		Layers += 1
		Exp = math.log10(Exp)
		return Cnew(Sign, Layers, Exp)	
	end

	local absExp = math.abs(Exp)
	local signExp = math.sign(Exp)

	if absExp >= expl then
		Layers += 1
		Exp = signExp * math.log10(absExp)
		return Cnew(Sign, Layers, Exp)
	else

		while absExp < ldown and Layers > 0 do
			Layers -= 1
			if Layers == 0 then
				Exp = math.pow(10, Exp)
			else
				Exp = signExp*math.pow(10, absExp)
				absExp = math.abs(Exp)
				signExp = math.sign(Exp)
			end
		end

		if Layers == 0 then

			if Exp < 0 then
				Exp =- Exp
				Sign =- Sign
			end

		elseif Exp == 0 then
			Sign = 0
		end

	end

	return Cnew(Sign, Layers, Exp)
end


function EN.new(Sign: number, Layer: number, Exp: number) : EN
	return EN.correct({Sign=Sign, Layer=Layer, Exp=Exp}	)
end


function EN.fromNumber(Value: number): EN  --// Convert a number to EtNum
	local num = {}
	num.Sign = math.sign(Value)
	num.Layer = 0
	num.Exp = math.abs(Value)
	return EN.correct(num)
end

function EN.fromScientific(Value: string): EN --// Convert from "XeY" to EtNum
	local slice = Value:split("e")

	local Mantissa = tonumber(slice[1])
	local Exp = tonumber(slice[2])
	local Sign = math.sign(Mantissa)

	--// Normalise Mantissa \\--
	local Overflow = math.floor(math.log10(Mantissa))
	if Overflow > 0 then
		Mantissa /= 10 ^ Overflow
		Exp += Overflow
	end
	-----------------------------

	if Exp == 0 then return EN.new(math.sign(Mantissa), 0, Mantissa) end --// x*10^0 (so just return x)
	if Mantissa == 0 then return ZERO end --// return 0

	if Mantissa < 0 then Mantissa =- Mantissa end

	if Exp < 0 then
		if Exp < -100 then return ZERO end
		local Exp2 =  math.log10(Mantissa) + Exp
		return EN.correct(EN.new(Sign, 1,Exp2))
	end

	local Exp2 = math.log10(Mantissa) + Exp
	local Layers = 1

	if Exp2 > expl then
		Exp2 = math.log10(Exp2)
		Layers += 1
	end

	return EN.correct(EN.new(Sign, Layers, Exp2))
end

function EN.fromDefaultStringFormat(Value: string) : EN --// Convert "X;Y" to EtNum
	local slice = Value:split(";")
	local Sign = math.sign(tonumber(slice[1]))
	if Sign == 0 then Sign = 1 end 
	local Layers = math.abs(tonumber(slice[1]))
	local Exp = tonumber(slice[2])
	return EN.correct(EN.new(Sign, Layers, Exp))
end


function EN.fromString(Value: string)
	if Value:find("e") and not Value:find(";") then -- Assuming its scientific notation
		return EN.fromScientific(Value)
	elseif Value:find(";") then -- String representation
		return EN.fromDefaultStringFormat(Value)
	end

	if Value == "NaN" then return NaN end
	if Value == "Inf" then return Inf end
	if Value == "" then return DefaultReturn end

	return EN.fromNumber(tonumber(Value))
end

function EN.toString(Value: EN) : string
	if EN.IsNaN(Value) then return "NaN" end
	if EN.IsInf(Value) then return "Inf" end
	return  Value.Layer .. ";" .. Value.Exp
end

function EN.convert(Input) : EN --// Convert any valid type to EternityNum
	if typeof(Input) == "number" then
		return EN.fromNumber(Input)
	elseif typeof(Input) == "string" then
		return EN.fromString(Input)
	elseif typeof(Input) == "table" then
		if #Input == 2 then -- Its a BigNum (Adding this because if people are updating for "BigNum")
			local String = Input[1] .. "e" .. Input[2]
			return EN.fromScientific(String)
		elseif #Input == 3 then
			return EN.correct(EN.new(Input[1], Input[2], Input[3]))
		elseif Input.Sign then
			return EN.correct(EN.new(Input.Sign, Input.Layer, Input.Exp))
		end
	end
	warn("Returning DefaultReturn at EN.Convert(): Invalid input!")
	return DefaultReturn
end


function EN.toNumber(Value: EN) : number --// Convert a EtNum to an number

	if Value.Layer > 1 then 
		if math.sign(Value.Exp) == -1 then
			return Value.Sign * 0
		end
		return Value.Sign * 1.8e308	
	end

	if Value.Layer == 0 then
		return Value.Sign * Value.Exp
	elseif Value.Layer == 1 then
		return Value.Sign * 10 ^ Value.Exp
	end

	return math.log10(-1)
end

function EN.abs(Value) : EN
	Value = EN.convert(Value)

	if Value.Sign == 0 then
		return ZERO
	end
	return EN.new(1, Value.Layer, Value.Exp)
end

function EN.maxAbs(Value, Value2) 
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	if EN.cmpAbs(Value, Value2) < 0 then return Value2 end
	return Value
end

function EN.neg(Value): EN --// Negate a EtNum
	Value = EN.convert(Value)
	return EN.new(-Value.Sign, Value.Layer, Value.Exp)
end


function EN.cmpAbs(Value: EN, Value2: EN) : number
	local layera = nil
	if Value.Exp  > 0 then
		layera = Value.Layer
	else
		layera =- Value.Layer
	end

	local layerb = nil
	if Value2.Exp  > 0 then
		layerb = Value2.Layer
	else
		layerb =- Value2.Layer
	end

	if layera > layerb then return 1 end
	if layera < layerb then return -1 end
	if Value.Exp > Value2.Exp then return 1 end
	if Value.Exp < Value2.Exp then return -1 end

	return 0
end

function EN.cmp(Value: EN, Value2: EN) : number
	if Value.Sign > Value2.Sign then return 1 end
	if Value.Sign < Value2.Sign then return -1 end
	return Value.Sign * EN.cmpAbs(Value, Value2)
end

function EN.le(Value, Value2) : boolean --// <
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return EN.cmp(Value, Value2) == -1
end

function EN.me(Value, Value2) : boolean --// >
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return EN.cmp(Value, Value2) == 1
end

function EN.eq(Value, Value2) : boolean --// ==
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return EN.cmp(Value, Value2) == 0
end

function EN.leeq(Value, Value2) : boolean --// ==
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return not (EN.cmp(Value, Value2) == 1)
end

function EN.meeq(Value, Value2) : boolean --// ==
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return not (EN.cmp(Value, Value2) == -1 )
end

function EN.recip(Value) : EN
	Value = EN.convert(Value)
	if Value.Exp == 0 then return NaN end

	if Value.Layer == 0 then 
		return EN.new(Value.Sign, 0, 1/Value.Exp) 
	end

	return EN.new(Value.Sign, Value.Layer, -Value.Exp)
end


function baseLog(Value, Base) : EN
	Value = EN.convert(Value)
	Base = EN.convert(Base)

	if Value.Sign <= 0 or Base.Sign <= 0 then return NaN end

	if EN.IsNaN(Base) or EN.IsNaN(Value) then
		return NaN
	end

	if Value.Layer == 0 and Base.Layer == 0 then
		return EN.new(Value.Sign, 0, math.log(Value.Exp) / math.log(Base.Exp))
	end

	return EN.div(EN.log10(Value), EN.log10(Base))
end

function EN.log(Value, Base) : EN --// Log of x
	if Base then
		return baseLog(Value, Base)
	end

	Value = EN.convert(Value)

	if Value.Sign <= 0 then return NaN end

	if Value.Layer == 0 then
		return EN.new(Value.Sign, 0, math.log10(Value.Exp))
	elseif Value.Layer == 1 then
		--// so we have this for x*10^y, since log(x) = log10(x) * log(10) we can do exactly that!
		return EN.new(math.sign(Value.Exp), 0, math.abs(Value.Exp) * 2.302585092994046)
	elseif Value.Layer == 2 then
		--// 10^(x*10^y), turns out you can just take the log10 and then add log10(log(10)) to the exponent
		return EN.new(math.sign(Value.Exp), 1, math.abs(Value.Exp) + 0.36221568869946325)
	end
	--// log(x) ~ log10(x) at this point so we just return the log10

	return EN.new(math.sign(Value.Exp), Value.Layer-1, math.abs(Value.Exp))
end


function EN.log10(Value) : EN --// log10(x)
	Value = EN.convert(Value)

	if Value.Sign <= 0 then return NaN end

	if Value.Layer > 0 then
		return EN.new(math.sign(Value.Exp), Value.Layer - 1, math.abs(Value.Exp))
	end

	return EN.new(Value.Sign, 0 , math.log10(Value.Exp))
end

function EN.exp(Value) : EN --// e^x
	Value = EN.convert(Value)

	if Value.Layer == 0 and Value.Exp <= 709.7 then
		return EN.fromNumber(math.exp(Value.Sign * Value.Exp))
	elseif Value.Layer == 0 then
		return EN.new(1, 1, Value.Sign * math.log10(2.718281828459045) * Value.Exp)
	elseif Value.Layer == 1 then
		return EN.new(1, 2, Value.Sign * (math.log10(0.4342944819032518) + Value.Exp))
	else
		return EN.new(1, Value.Layer + 1, Value.Sign * Value.Exp)
	end
end

function EN.add(Value, Value2) : EN
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	if EN.IsInf(Value) or EN.IsInf(Value2) then return Inf end
	if EN.IsZero(Value) then return Value2 end
	if EN.IsZero(Value2) then return Value end
  
	if Value.Sign == -Value2.Sign and Value.Layer == Value2.Layer and Value.Exp == Value2.Exp then
		return ZERO
	end

	local a,b

	if Value.Layer >= 2 or Value2.Layer >=2 then
		return EN.maxAbs(Value, Value2)
	end	

	if EN.cmpAbs(Value, Value2) > 0 then
		a = Value
		b = Value2
	else
		a = Value2
		b = Value	
	end

	if a.Layer == 0 and b.Layer == 0 then
		return EN.fromNumber(a.Sign * a.Exp + b.Sign * b.Exp)
	end

	local layera = a.Layer * math.sign(a.Exp)																		
	local layerb = b.Layer * math.sign(b.Exp)	

	if layera - layerb >= 2 then return a end

	if layera == 0 and layerb == -1 then
		if math.abs(b.Exp - math.log10(a.Exp)) > msd then
			return a
		else
			local magdif = 10 ^ a.Exp - math.log10(b.Exp)
			local Mantissa = b.Sign + a.Sign * magdif
			return EN.new(math.sign(Mantissa), 1, math.log10(b.Exp) + math.log10(math.abs(Mantissa)))
		end
	end
	
	if layera == 1 and layerb == 0 then
		if math.abs(a.Exp - math.log10(b.Exp)) > msd then return a end
		local magdif = 10 ^ (a.Exp-math.log10(b.Exp))
		local Mantissa = b.Sign + a.Sign * magdif
		return EN.new(math.sign(Mantissa), 1, math.log10(b.Exp) + math.log10(math.abs(Mantissa)))
	end

	if math.abs(a.Exp - b.Exp) > msd then return a end

	local magdif = 10 ^ (a.Exp - b.Exp)
	local Mantissa = b.Sign + a.Sign * magdif
	return EN.new(math.sign(Mantissa), 1,b.Exp + math.log10(math.abs(Mantissa)))
end

function EN.sub(Value, Value2) : EN
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return EN.add(Value, EN.neg(Value2))
end

function EN.toScientific(Value: EN) : string
	if Value.Layer > 2 then if AllowOverflow then return "" end return "Inf" end
	if Value.Layer == 2 and Value.Exp > 308 then return "Inf" end
	if EN.IsZero(Value) then return "0e0" end 
	
	if Value.Layer == 0 then 
		local Mantissa = (Value.Exp /  10^ math.floor(math.log10(Value.Exp))) * Value.Sign
		return Mantissa .. "e" .. math.floor(math.log10(Value.Exp))
	elseif Value.Layer == 1 then
		local Mantissa = (10 ^ (Value.Exp - math.floor(Value.Exp))) * Value.Sign
		return Mantissa .. "e" .. math.floor(Value.Exp)
	end

	local Exp = 10 ^ Value.Exp
	local Mantissa = (10  ^ (Exp - math.floor(Exp)))* Value.Sign
	return Mantissa .. "e" .. math.floor(Exp)
end



function EN.mul(Value, Value2) : EN
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)

	if EN.IsInf(Value) or EN.IsInf(Value2) then
		return Inf
	end

	if EN.IsZero(Value) or EN.IsZero(Value2) then
		return ZERO
	end

	if Value.Layer == Value2.Layer and Value.Exp == -Value2.Exp then
		return EN.new(Value.Sign * Value2.Sign, 0, 1)
	end

	local a: EN,b: EN 

	if (Value.Layer > Value2.Layer) or (Value.Layer == Value2.Layer and math.abs(Value.Exp) > math.abs(Value2.Exp)) then
		a = Value
		b = Value2
	else
		a = Value2
		b = Value	
	end
	
	if a.Layer == 0 and b.Layer == 0 then
		return EN.fromNumber(a.Sign * b.Sign * a.Exp * b.Exp)
	end
	if a.Layer >= 3 or (a.Layer - b.Layer >= 2) then
		return EN.new(a.Sign * b.Sign, a.Layer, a.Exp)
	end
	if a.Layer == 1 and b.Layer == 0 then
		return EN.new(a.Sign * b.Sign, 1, a.Exp + math.log10(b.Exp))
	end
	if a.Layer == 1 and b.Layer == 1 then
		return EN.new(a.Sign * b.Sign, 1, a.Exp + b.Exp)
	end

	if (a.Layer == 2 and b.Layer == 1) or (a.Layer == 2 and b.Layer == 2) then
		local temp = EN.new(math.sign(b.Exp), b.Layer - 1, math.abs(b.Exp))
		local nmag = EN.add(EN.new(math.sign(a.Exp), a.Layer-1, math.abs(a.Exp)), temp)
		return EN.new(a.Sign * b.Sign, nmag.Layer + 1, nmag.Sign * nmag.Exp)
	end

	return NaN
end

function EN.div(Value, Value2) : EN
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return EN.mul(Value, EN.recip(Value2))
end

function EN.abslog10(Value) : EN
	Value = EN.convert(Value)
	if EN.IsZero(Value) then return NaN end

	if Value.Layer > 0 then
		return EN.new(math.sign(Value.Exp), Value.Layer - 1, math.abs(Value.Exp))
	end

	return EN.new(1, 0, math.log10(math.abs(Value.Exp)))
end

function EN.pow10(Value) : EN

	Value = EN.convert(Value)

	if EN.IsInf(Value) then return Inf end
	if Value.Layer == 0 then
		local nmag = 10 ^ (Value.Sign * Value.Exp)
		if nmag < 1.8e308 and math.abs(nmag) > 0.1 then
			return EN.new(1, 0, nmag)
		else
			if Value.Sign == 0 then return ONE end
			Value = EN.new(Value.Sign, Value.Layer + 1, math.log10(Value.Exp)) 
		end
	end

	if Value.Sign > 0 and Value.Exp > 0 then

		return EN.new(Value.Sign, Value.Layer + 1, Value.Exp)	
	end
	if Value.Sign < 0 and Value.Exp > 0 then
		return EN.new(-Value.Sign, Value.Layer + 1, -Value.Exp)	
	end

	return ONE
end


function EN.pow(Value, Value2) : EN
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	if EN.IsZero(Value) then -- 0^x = 0
		return ZERO
	end

	if Value.Sign == 1 and Value.Layer == 0 and Value.Exp == 1 then -- 1^x = 1
		return ONE
	end
	if EN.IsZero(Value2) then -- x^0 = 1
		return ONE
	end
	if Value2.Sign == 1 and Value2.Layer == 0 and Value2.Exp == 1 then -- 1^x = 1
		return Value
	end

	local calc = EN.pow10(EN.mul(EN.abslog10(Value), Value2)) 
	if Value.Sign == -1 and EN.toNumber(Value2) % 2 == 1 then
		return EN.neg(calc)
	elseif Value.Sign == -1 and EN.toNumber(Value2) < 1e20 then
		local component = EN.fromNumber(math.cos(EN.toNumber(Value2) * math.pi))
		return EN.mul(calc, component)
	end

	return calc
end

--------------------------------------------------------------------------------------

local Sets = {"k","M","B"}
local FirstOnes = {"", "U","D","T","Qd","Qn","Sx","Sp","Oc","No"}
local SecondOnes = {"", "De","Vt","Tg","qg","Qg","sg","Sg","Og","Ng"}
local ThirdOnes = {"", "Ce", "Du","Tr","Qa","Qi","Se","Si","Ot","Ni"}
local MultOnes = {
	"", "Mi","Mc","Na","Pi","Fm","At","Zp","Yc", "Xo", "Ve", "Me", 
	"Due", "Tre", "Te", "Pt", "He", "Hp", "Oct", "En", "Ic", "Mei", 
	"Dui", "Tri", "Teti", "Pti", "Hei", "Hp", "Oci", "Eni", "Tra","TeC",
	"MTc","DTc","TrTc","TeTc","PeTc","HTc","HpT","OcT","EnT","TetC","MTetc",
	"DTetc","TrTetc","TeTetc","PeTetc","HTetc","HpTetc","OcTetc","EnTetc","PcT",
	"MPcT","DPcT","TPCt","TePCt","PePCt","HePCt","HpPct","OcPct","EnPct","HCt",
	"MHcT","DHcT","THCt","TeHCt","PeHCt","HeHCt","HpHct","OcHct","EnHct","HpCt",
	"MHpcT","DHpcT","THpCt","TeHpCt","PeHpCt","HeHpCt","HpHpct","OcHpct","EnHpct",
	"OCt","MOcT","DOcT","TOCt","TeOCt","PeOCt","HeOCt","HpOct","OcOct","EnOct","Ent","MEnT",
	"DEnT","TEnt","TeEnt","PeEnt","HeEnt","HpEnt","OcEnt","EnEnt","Hect", "MeHect"}

function CutDigits(Value, Digits)
	if Digits < 0 then return Value end
	return math.floor(Value * 10 ^ Digits) / 10 ^ Digits
end

function EN.toSuffix(Value: EN, Digits: number) : string

	Digits = Digits or DefaultDigits
	local BigNum = EN.toScientific(Value):split("e")
	local Mantissa = BigNum[1]
	local Exponent = BigNum[2]
	local Modulus3 = math.fmod(Exponent, 3)
	Exponent = math.floor(Exponent / 3) - 1

	if Exponent <= -1 then return CutDigits(BigNum[1] * 10 ^ BigNum[2], Digits) end
       
	if Exponent < 3 then
		return CutDigits(Mantissa * 10 ^ Modulus3, Digits) .. Sets[Exponent + 1]
	end

	local OutString = ""

	local function SuffixPartOne(n)

		local Hundreds = math.floor(n / 100)
		n = math.fmod(n, 100)
		local Tens = math.floor(n / 10)
		n = math.fmod(n, 10)
		local Ones = math.floor(n / 1)

		OutString = OutString .. FirstOnes[Ones + 1]
		OutString = OutString .. SecondOnes[Tens + 1]
		OutString = OutString .. ThirdOnes[Hundreds + 1]

	end

	local function SuffixPartTwo(n)
		if n > 0 then n += 1 end
		if n > 1000 then n = math.fmod(n, 1000) end
		SuffixPartOne(n)
	end

	if Exponent < 1000 then
		SuffixPartOne(Exponent)
		return CutDigits(Mantissa * 10 ^ Modulus3, Digits)  .. OutString
	end

	for i=math.floor(math.log10(Exponent) / 3), 0, -1 do
		if Exponent >= 10^(i*3) then
			SuffixPartTwo(math.floor(Exponent / 10 ^ (i * 3)) - 1)
			OutString = OutString .. MultOnes[i + 1]
			Exponent = math.fmod(Exponent, 10 ^ (i * 3))
		end
	end

	return CutDigits(Mantissa * 10 ^ Modulus3, Digits)  .. OutString
end

function EN.between(Val, x, y) : boolean
	Val = EN.convert(Val)
	x = EN.convert(x)
	y = EN.convert(y)
	return EN.me(Val, x) and EN.le(Val, y)
end

function EN.toLayerNotation(Value, Digits : number) : string
	Value = EN.convert(Value)
	Digits = Digits or DefaultDigits

	if EN.between(Value, ZERO, ONE) then
		return "1 / " .. EN.short(EN.div(ONE, Value)) 
	end

	if Value.Sign == 1 then

		if Value.Exp < 0 then
			return 'E(' .. Value.Layer .. '-' ..  ')' .. CutDigits(math.abs(Value.Exp), Digits)
		end

		return 'E(' .. Value.Layer ..  ')' .. CutDigits(Value.Exp, Digits)
	end

	if Value.Sign == 0 then
		return 'E(0)0'
	end

	return EN.toLayerNotation(EN.abs(Value), Digits)
end

function EN.short(Value, Digits) : string
	Value = EN.convert(Value)
	if EN.le(Value, SuffixLimit) then
		return EN.toSuffix(Value, Digits)
	end
	return EN.toLayerNotation(Value, Digits)
end

function EN.root(Value, Value2) : EN
	Value = EN.convert(Value)
	Value2 = EN.convert(Value2)
	return EN.pow(Value, EN.recip(Value2))
end

function EN.sqrt(Value) : EN
	Value = EN.convert(Value)
	return EN.root(Value, 2)
end

function EN.gamma(Value) : EN
	Value = EN.convert(Value)

	if EN.leeq(Value, ZERO) then return NaN end
	if Value.Exp < 0 then return EN.recip(Value) end

	if Value.Layer == 0 then
		if EN.le(Value, {1, 0, 24}) then
			return EN.fromNumber(F_Gamma(Value.Sign * Value.Exp))
		end

		local t = Value.Exp - 1
		local l = 0.9189385332046727
		l = (l + ((t + 0.5) * math.log(t)))
		l = l - t
		local n2 = t * t
		local np = t
		local lm = 12 * np
		local adj = 1 / lm
		local l2 = l + adj

		if (l2 == l) then return EN.exp(l) end

		l = l2
		np = np * n2
		lm = 360 * np
		adj = 1 / lm
		l2 = l - adj

		if l2 == l then return EN.exp(l) end

		l = l2
		np = np * n2
		lm = 1260 * np
		local lt = 1 / lm
		l = l + lt
		np = np * n2
		lm = 1680 * np
		lt = 1 / lm
		l = l - lt

		return EN.exp(l)

	elseif Value.Layer == 1 then 
		return EN.exp(EN.mul(Value, EN.sub(EN.log(Value), 1)))
	end

	return EN.exp(Value)
end

function EN.fact(Value) : EN
	Value = EN.convert(Value)
	return EN.gamma(EN.add(Value, 1))
end


function EN.rand(min, max) : EN
	local seed = math.random()
	local even = EN.sub(max, min)
	even = EN.mul(even, seed)
	return EN.add(even, min)
end

function EN.exporand(min, max) : EN
	local min, max = EN.convert(min), EN.convert(max)
	local sign, sign2 = min.Sign, max.Sign
	local min = EN.mul(EN.exp(EN.abs(min)), sign)
	local max = EN.mul(EN.exp(EN.abs(max)), sign2)
	return EN.exp(EN.rand(min, max))
end


function EN.lbencode(enum) : number -- encode cool!
	enum = EN.convert(enum)
	if EN.eq(enum, 1) then return 1 end
	local mode = 0
	if enum.Sign == -1 and enum.Layer > 9999  and math.sign(enum.Exp) == 1 then
		mode = 0
	elseif enum.Sign == -1 and enum.Layer < 9999 and math.sign(enum.Exp) == 1 then
		mode = 1
	elseif enum.Sign == -1 and enum.Layer > 9999 and math.sign(enum.Exp) == -1 then
		mode = 2
	elseif enum.Sign == -1 and enum.Layer < 9999 and math.sign(enum.Exp) == -1 then
		mode = 3
	elseif enum.Sign == 0 then
		return 4E18
	elseif enum.Sign == 1 and enum.Layer < 9999 and math.sign(enum.Exp) == -1 then
		mode = 5
	elseif enum.Sign == 1 and enum.Layer > 9999 and math.sign(enum.Exp) == -1 then
		mode = 6
	elseif enum.Sign == 1 and enum.Layer < 9999 and math.sign(enum.Exp) == 1 then
		mode = 7
	elseif enum.Sign == 1 and enum.Layer > 9999 and math.sign(enum.Exp) == 1 then
		mode = 8
	end

	local VAL = mode*1E18
	if mode == 8 then
		VAL += ((math.log10(enum.Layer + (math.log10(enum.Exp) / 10))) * 3.2440674117208e+15)
	elseif mode == 7 then
		VAL += (enum.Layer * 1e14)
		VAL +=  (math.log10(enum.Exp) * 1e13)
	elseif mode == 6 then
		VAL += 1e18
		VAL -= ((math.log10(enum.Layer + (math.log10(math.abs(enum.Exp)) / 10))) * 3.2440674117208e+15)
	elseif mode == 5 then
		VAL += (enum.Layer * 1e14) + 1e14
		VAL -= (math.log10(math.abs(enum.Exp)) * 1e13)
	elseif mode == 3 then
		local VOFFSET = 0
		VAL += (enum.Layer * 1e14) + 1e14
		VAL -= (math.log10(math.abs(enum.Exp)) * 1e13)
		VOFFSET = (1e18 - VOFFSET)
		VAL += VOFFSET
	elseif mode == 2 then
		local VOFFSET = 0
		VAL += 1e18
		VAL -= ((math.log10(enum.Layer + (math.log10(math.abs(enum.Exp)) / 10))) * 3.2440674117208e+15)
		VOFFSET = (1e18 - VOFFSET)
		VAL += VOFFSET
	elseif mode == 1 then
		local VOFFSET = 0
		VAL += (enum.Layer * 1e14)
		VAL += (math.log10(enum.Exp) * 1e13)
		VOFFSET = (1e18 - VOFFSET)
		VAL += VOFFSET
	elseif mode == 0 then
		local VOFFSET = ((math.log10(enum.Layer + (math.log10(enum.Exp) / 10))) * 3.2440674117208e+15)
		VOFFSET = (1e18 - VOFFSET)
		VAL += VOFFSET
	end

	return VAL
end


function EN.lbdecode(enum : number) : EN -- decodes numbers for extra spice
	if enum == 2e18 then
		return EN.new(-1, 0, 1)
	elseif enum == 3e18 then
		return EN.new(-1, 10000, -1)
	elseif enum == 1e18 then
		return EN.new(-1, 0, -1)
	elseif enum == 6e18 then
		return ONE
	elseif enum == 7e18 then
		return EN.new(1, 10000, 1)
	elseif enum == 5e18 then
		return EN.new(1, 10000, -1)
	elseif enum == 1 then
		return ONE
	end

	local mode = math.floor(enum / 1e18)
	if mode == 4 then
		return ZERO
	end

	if mode == 0 then
		local v = enum
		v = 1e18 - v
		v /= 3.2440674117208e+15
		v = 10 ^ v
		local layers = math.floor(v)
		local numbaa = 10 ^ (math.fmod(v, 1) * 10)
		return EN.new(-1, layers, numbaa)

	elseif mode == 8 then
		local v = enum - 8e18
		v /= 3.2440674117208e+15
		v = 10 ^ v
		local layers = math.floor(v)
		local numbaa = 10 ^ (math.fmod(v, 1) * 10)
		return EN.new(1, layers, numbaa)

	elseif mode == 1 then
		local v = enum - 1e18
		v = 1e18-v
		local layers = math.floor(v / 1E14)
		local numbaa = 10 ^ (math.fmod(v, 1e14) / 1e13)
		return EN.new(-1, layers, numbaa)

	elseif mode == 7 then
		local v = enum - 7e18
		local layers = math.floor(v / 1E14)
		local numbaa = 10 ^ (math.fmod(v, 1e14) / 1e13)
		return EN.new(1, layers, numbaa)

	elseif mode == 2 then
		local v = enum - 2e18
		v /= 3.2440674117208e+15
		v = 10 ^ v
		local layers = math.floor(v)
		local e = 10 ^ (math.fmod(v,1) * 10)
		return EN.new(-1, layers, -e)

	elseif mode == 6 then
		local v = enum - 6e18
		v = (1e18 - v)
		v /= 3.2440674117208e+15
		v = 10 ^ v
		local layers = math.floor(v)
		local e = 10 ^ (math.fmod(v,1) * 10)
		return EN.new(1, layers, -e)

	elseif mode == 5 then
		local v = enum - 5e18
		local layers = math.floor((v) / 1E14)
		local e = 10 ^ ((1e14 - math.fmod(v, 1e14)) / 1e13)
		return EN.new(1, layers, -e)

	elseif mode == 3 then
		local v = enum - 3e18
		v = (1e18 - v)
		local layers = math.floor((v) / 1E14)
		local e = 10 ^ ((1e14 - math.fmod(v, 1e14)) / 1e13)
		return EN.new(-1, layers, -e)

	end

	return NaN
end

function EN.shift(Value, digits)
	Value = EN.convert(Value)
	if Value.Layer > 1 then return Value end
	if digits > 20 then return Value end 
	local d = 10 ^ (Value.Exp - math.floor(Value.Exp))
	d = math.floor(digits * 10^digits) / 10^digits
	Value.Exp = math.floor(Value.Exp) + math.log10(d)
	return Value
end


return EN
]]></ProtectedString>
						<int64 name="SourceAssetId">12144172446</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX00251866F8E040818EFBFB30AAF2DFDA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">OmegaNum</string>
						<string name="ScriptGuid">{423B630F-B09F-4669-9A72-D25DED570C54}</string>
						<ProtectedString name="Source"><![CDATA[-- Making OmegaNum 
-- By: FoundForces (CommanderSalty#4975)
-- Limit will be 10↑↑↑...↑↑↑10 with 1e3? ↑'s
-- Big thanks / Credits to [REDACTED] for help with errorcorrect and for lbencode and lbdecode!

--Config--
local NAN = 0/0 -- NAN constant.
local INF = 2e308 -- INF constant.
local paraForCorrect = 2 -- Amount of loops in errorcorrect (keep 2).
local maxInt = 2^53-1 -- Max integer thats allowed in a array.
local maxADD = "e" .. maxInt
local maxMUL = 'ee' .. maxInt -- Max Diff for mul
local maxPOW = {1, {1, maxInt}} -- Max Diff for pow
local maxH = math.log10(maxInt) -- Lowest integer thats for first number.
local signif = 2^53 -- Recommended to keep on 2^53 (consant of if x is bigger then signif dont do -1).
local amoes = 10 -- Constant where eee..eex goes to e[y]x.
local PrecisionDisplay = 3 -- Amount of digits of ouput display.
local toScientific = 1e306 -- Point where X gets converted to XeN in Display, must be less or equal to maxInt.
local signifDiff = 20 -- Difference where sub, add returns biggest value, recommended to keep on 20.
local ZERO = {1, {0}} -- Zero constant
local ONE = {1,{1}}
local maxAllowed = 1.797693015e308
local maxSuffix = {1, {3000000, 1}} -- max value to return suffix at short
local maxScientific = "eeee300008"
local maxEs = 10
local INF = 2e308
local ArrowLimit = 254
local pi = 3.14159265358979323846
-----------

--[[
Functions,

correct: corrects a omeganum
fromNumber: converts a number to omeganum
toNumber: converts a omeganum to number
toDisplay: displays in arrow notation
toString: converts a omeganum to string (USE THIS FOR STORING VALUES)
fromString: converts a string to omeganum
toOmega
eq
le
me
meeq
leeq
abs
neg
cmp
max
min
log10
isint
recip
pow
mod
root
mul
floor
ceil
div
add
sub
sqrt
log
exp
maxabs
eternitytoOmega
pow10
gamma
fact
rand
exporand
toBigNum
toScientific
toShortScientific
short
toEnt
toShortEnt
toEs
toShortEs
toHyperE
toShortHyperE
lambertw
slog
tetrate
pentate
lbencode
lbdecode

]]

trunc = function (n) -- math function
	if math.ceil(n) == n then return n end
	if n < 0 then
		return -(math.floor(n))
	end
	return math.floor(n)
end

function fgamma(n)
	local C = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7}
	if math.floor(n) == n then
		return fact(n-1)
	end
	if (n > 0.5) then 
		n -= 1
		local x = C[1]
		for i=1,7 do
			x += C[i+1] / (n + i)
		end
		local t = n + 7.5
		return  x * t^(n+0.5 - 36) * math.exp(-t) * t^36 * 2.50662827463100050241576528
	end
	return 3.141592653589793238 / (math.sin(3.141592653589793238 * n) * fgamma(1 - n))
end

function f_lambertw(z)
	local tol = 1e-10
	local w,wn = nil
	if z > 1.79e308 then return z
	end
	if z == 0 then
		return z
	end
	if z == 1 then
		return 0.56714329040978387299997
	end
	if z < 10 then
		w = 0
	else
		w = math.log(z)-math.log(math.log(z))
	end
	for i=1,100 do
		wn = (z * math.exp(-w) + w * w)/(w + 1)
		if math.abs(wn - w) < tol*math.abs(wn) then
			return wn
		else
			w = wn
		end

	end
	warn("Failed at W")
	return 0/0
end

function Hlambertw(n)
	local tol = 1e-10
	n = ree.correct(n)
	local wn;
	local w = ree.log(n)
	for i=1,100 do
		wn = ree.div(ree.add(ree.mul(n,ree.exp(ree.neg(w))),ree.mul(w,w)),ree.add(w,1))
		if ree.le(ree.abs(ree.sub(wn,w)), ree.mul(tol,ree.abs(wn))) then
			return wn
		end
		w = wn
	end
	warn("Failed at hlam")
	return NAN
end

ree = {}

function ree.correct(val)
	if val == nil then return ZERO end
	if val ~= val then return NAN end
	if type(val) ~= 'table' then
		return ree.toOmega(val)
	end
	if type(val[2]) ~= "table" and #val == 2 then
		val = {math.sign(val[1]), {val[2] + math.log10(math.abs(val[1])),1}}
	end
	if type(val[2]) ~= "table" then
		val = {1,val}
	end
	if #val[2] == 0 then
		return ZERO
	end
	if (val[1] == 1 or val[1] == -1) and #val[2] == 1 and val[2][1] == 0 or  #val[2] == 2 and val[2][1] == 0  and val[2][2] == 0 then
		return {val[1],{0}}
	end
	-- {sign, {}}
	local qq = copytab(val)
	local sign = qq[1]
	local array = qq[2]
	array = array or {0}
	sign = sign or 1
	local len = #array
	-- Handle bullshit correctly
	for i=len,1,-1 do
		if array[i] == 0 then
			table.remove(array)
			len -= 1
		else
			break
		end
	end
	if array[1] > maxInt then
		array[1] = math.log10(array[1])
		if len > 1 then
			array[2] += 1
		else
			table.insert(array, 1)
			len += 1
		end
	end
	-- handle 1,0,0,0,x
	if len > 2 then
		if array[2] < 3 then
			for i=1,array[2] do
				if array[i] >= math.log10(maxInt) then
					break
				elseif array[2] == 0 then
					break
				end
				array[i] = 10^array[i]
				array[2] -= 1
			end 
		end
		if array[2] == 0 then
			if array[1] == 1 then
				for i=2,len do
					if array[i] == 0 then
						continue
					elseif array[i] > 1 then
						break
					elseif array[i] == 1 and i == len then
						return {sign, {10}}
					end
				end 
			end
			local LastZero = 2
			local OneEncountered = false
			for i=3,#array do
				if array[i] == 0 then
					LastZero = i
				elseif array[i] == 0 and OneEncountered then
					continue
				elseif array[i] == 1 and OneEncountered  then
					break
				elseif array[i] == 1  then
					OneEncountered = true
				else
					break
				end
			end
			if LastZero == len then
				return {sign, {array[1]}}
			else
				local Mode = 1
				if array[1] == 1 then Mode = OneEncountered and 1 or 2 array[1] = 10 end
				array[LastZero] = array[1] - 2
				array[1] = 1e10
				for i=2,LastZero - 1 do
					array[i] = 8
				end
				array[LastZero + 1] -= Mode
				for i=#array,2,-1 do
					if array[i] == 0 then
						array[i] = nil
					else
						break
					end
				end
				-- Loop through LastZero
				--return {sign, array}
			end
		end
	end
	len = #array
	for i=len,1,-1 do
		if array[i] == 0 then
			table.remove(array)
			len -= 1
		else
			break
		end
	end
	if len > 1 then
		if array[1] < math.log10(maxInt) and array[2] > 0  then
			array[2] -= 1
			array[1] = 10^array[1]
			array[2] = (array[2] == 0) and nil or array[2] 
		end
		if array[1] < math.log10(maxInt) and array[2] > 0  then
			array[2] -= 1
			array[1] = 10^array[1]
			array[2] = (array[2] == 0) and nil or array[2] 
		end
	end
	for i=2,len do
		if array[i]>maxInt then
			array[1] = array[i]
			array[i+1] = (array[i+1] or 0)+1
			array[i]+=1
			for j=2,i do
				array[j] = 0
			end
			if array[1] > maxInt then
				array[1] = math.log10(array[1])
				array[2]+=1
			end
		end
	end
	-- Convert trailing zeros
	-- Remove trailing zeros
	-- loop until
	if qq[1] == 0 then
		return ZERO
	end
	for i=1,#array do
		local cur = array[i]
		if cur == NAN then
			warn('correct() returning NAN')
			return qq
		end
		if cur==INF then
			return qq
		end
		if cur % 1 ~= 0 and i~= 1 then
			array[i] = math.floor(cur)
		end
	end
	if not #array then qq[2] = {0} end
	return qq
end

function ree.fromNumber(val)
	if type(val) ~= 'number' then
		error('NAN input at fromNumber()')
	end
	if val == 0 then
		return ZERO
	end
	return ree.correct({math.sign(val), {math.abs(val)}})
end

function ree.toNumber(val)
	val = ree.correct(val)
	local array = val[2]
	local sign = val[1]
	if #array >=2 and (array[2]>=2 or (array[2] ==1 and array[1]>math.log10(maxAllowed))) then
		return INF*sign
	end
	return array[2] == 1 and 10^array[1]*sign or array[1]*sign
end

function ree.toDisplay(val)
	local val1 = ree.correct(val)
	local array = val1[2]
	local sign = val1[1]
	if array[1] == NAN then
		return 'NaN'
	end
	if array[1] > INF then
		return 'Infinity'
	end
	if #array == 2 then
		local es = ''
		local esign = ''
		if sign == 0 then
			return '0'
		end
		if sign < 0 then
			esign = '-'
		end
		local base = 1
		if math.fmod(array[1],1) ~= 0 then
			base = 10^(array[1]-math.floor(array[1]))
			array[1] = math.floor(array[1])
		end
		if array[2] > amoes then
			return  esign .. 'e[' .. array[2]-1 .. ']' .. base .. 'e' .. array[1]
		end
		for i=1,array[2]-1 do
			es = es .. 'e'
		end
		return esign .. es .. base .. 'e' .. array[1]
	end
	local function Decimal(val, amo)
		local a = math.floor(val*10^amo)
		a = a/10^amo
		return a
	end
	if #array == 1 then
		if array[1] > toScientific then
			local esign = ''
			if sign == 0 then
				return '0'
			end
			if sign < 0 then
				esign = '-'
			end
			local exponent = math.floor(math.log10(array[1]))
			local base = array[1]/10^exponent
			return esign .. Decimal(base, PrecisionDisplay) .. 'e' .. exponent
		else
			return array[1]*sign
		end
	end
	if #array > 2 then
		local str = ''
		for i=#array,1,-1 do
			if i == 1 then
				str = str .. '|' ..  array[i]
				break
			end
			if array[i] ~= 0 then
				str = str .. '(10↑[' .. i-1 .. '])' .. array[i]
			end
		end
		return str
	end
end

function ree.toString(val)
	val = ree.correct(val)
	val[2][1] *= val[1]
	return game.HttpService:JSONEncode(val[2])
end

function ree.fromString(str)
	if str == "[0]" then
		return ZERO
	end
	if (string.find(str, 'e') or string.find(str, 'E')) and not string.find(str,"%[") then
		local subs = string.split(str, 'e')
		-- Fix problem with tetrate
		if subs[1] == "" then
			table.insert(subs, 1, "1")
			if subs[2] == "" then
				table.remove(subs, 2)
			end
		end
		if #subs == 2 then
			-- its scientific yk
			local n = false


			if subs[1]:find("-") then
				subs[1] = math.abs(subs[1])
				n = true
			end
			local first = subs[2]+math.log10(subs[1])
			if n then 
				first = -first
			end
			local second = 1
			local sign = math.sign(first)
			first = math.abs(first)
			return ree.correct({sign, {first, second}})
		else
			-- its a e chain!
			local second = #subs-1
			local first = subs[#subs]
			local sign = 1
			if subs[1] == '-' then
				sign = -1
			end
			return ree.correct({sign, {tonumber(first), second}})
		end
	end
	if string.find(str, ',') or string.find(str,"%[") then
		str = game.HttpService:JSONDecode(str)
		str = {math.sign(str[1] or 1), str}
		str[2][1] = math.abs(str[2][1] or 0)
		return ree.correct(str)
	else
		return ree.fromNumber(tonumber(str))
	end
end

function ree.toOmega(val)
	if type(val) == 'table' then
		-- Assuming its Omega type..
		-- For converting other Bnums please use assigned function.
		if #val < 2 then
			val = {1, val}
		end
		return val
	end
	if type(val) == 'number' then
		-- convert number to omega
		return ree.fromNumber(val)
	end
	if type(val) == 'string' then
		-- convert str to omega
		return ree.fromString(val)
	end
end

function ree.eq(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	return ree.cmp(val, val2) == 0 
end

function ree.le(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	return ree.cmp(val, val2) == -1
end

function ree.me(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	return ree.cmp(val, val2) == 1 
end

function ree.meeq(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	return ree.cmp(val, val2) >= 0 
end

function ree.leeq(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	return ree.cmp(val, val2) <= 0 
end

function ree.abs(val)
	val = ree.correct(val)
	return {1, val[2]}
end

function ree.neg(val)
	val = ree.correct(val)
	return {val[1]*-1, val[2]}
end

function ree.cmp(val, val2) -- 0 = eq, -1 = le, 1 = me 
	val = ree.correct(val)
	val2 = ree.correct(val2)
	local V1Nan = val ~= val
	if V1Nan and val2 ~= val2 then return 0
	elseif V1Nan or val2 ~= val2 then return 1
	end
	if val[1] == INF and val2[1] ~= INF then
		return val[1]
	end
	if val[1] ~= INF and val2[1] == INF then
		return -val2[1]
	end
	if #val[2]==1 and val[2][1]==0 and #val2[2]==1 and val2[2][1]==0 then
		return 0
	end
	if val[1] ~= val2[1] then
		return val[1]
	end
	local a = val[1]
	local z
	if #val[2] > #val2[2] then z=1 
	elseif #val[2] < #val2[2] then z=-1
	else
		for i=#val[2],1,-1 do
			if val[2][i] > val2[2][i] then
				z = 1
				break
			elseif val[2][i] < val2[2][i] then
				z = -1
				break
			end
		end
		z= z or 0
	end
	return z*a
end

--[[function ree.sub(val, val2)
	return ree.add(val, ree.neg(val2))
end]]

function ree.max(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	if ree.me(val, val2) then
		return val
	else
		return val2
	end
end

function ree.min(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	if ree.me(val, val2) then
		return val2
	else
		return val
	end
end

function copytab(v)
	local new = {}
	new[1] = v[1]
	new[2] = {}
	for i,v in next, v[2] do
		new[2][i] = v
	end
	return new
end

function ree.log10(val)
	val = ree.correct(val)
	if ree.eq(val , ZERO) then
		return ZERO
	end
	local val1 = copytab(val)
	if ree.le(val1, 0) then return NAN end
	if ree.eq(val1, 0) then return -INF end
	if ree.leeq(val1, maxInt) then return ree.fromNumber(math.log10(ree.toNumber(val1))) end
	val1[2][2] -= 1
	return ree.correct(val1) 
end

function ree.isint(val)
	val = ree.correct(val)
	if val[1] ==-1 then
		return ree.isint(ree.abs(val))
	end
	if ree.meeq(val, maxInt) then
		return true
	end
	return math.fmod(ree.toNumber(val),1) == 1
end

function ree.recip(val)
	val = ree.correct(val)
	if ree.me(ree.abs(val), "2e323") then return ZERO end
	return ree.div(1, val)
end

function ree.pow(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	local sign,sign2 = val[1],val2[1]
	local array,array2 = val[2],val2[2]
	if ree.eq(val2, 0) then
		return {1, {1}}
	end
	if ree.eq(val2, 1) then
		return val
	end
	if ree.le(val2, 0) then
		return ree.recip(ree.pow(val, ree.neg(val2)))
	end
	if ree.le(val, 0) and ree.isint(val2) then
		if ree.le(ree.mod(val2, 2), 1) then
			return ree.pow(ree.abs(val), val2)
		end
		return ree.neg(ree.pow(ree.abs(val), val2))
	end 
	if ree.le(val, ZERO) then
		return NAN
	end
	if ree.eq(val, 1) then
		return {1, {1}}
	end
	if ree.eq(val, ZERO) then
		return ZERO
	end
	if ree.meeq(ree.max(val,val2), maxPOW) then
		return ree.max(val, val2)
	end
	if ree.eq(val, 10) then
		if ree.me(val2, 0) then
			if array2[2] then
				array2[2] = array2[2]+1
			else
				array2[2] = 1
			end
			return ree.correct(val2)
		else
			return ree.fromNumber(10^ree.toNumber(val2))
		end
	end
	if ree.le(val2, 1) then
		ree.root(val,ree.recip(val2))
	end
	local ni = ree.toNumber(val)^ree.toNumber(val2)
	if ni<= maxInt then
		return ree.fromNumber(ni)
	end
	local f = ree.log10(val)
	local exporrrrrrrrrr =  ree.mul(f, val2)
	return ree.pow(10, exporrrrrrrrrr)
end

function ree.mod(val, val2)
	val = ree.correct(val)
	val2 = ree.correct(val2)
	local sign,sign2 = val[1],val2[1]
	if ree.eq(val,ZERO) then
		return ZERO
	end
	if sign*sign2 == -1 then
		return ree.neg(ree.mod(ree.abs(val), ree.abs(val2)))
	end
	if sign == -1 then
		return ree.mod(ree.abs(val), ree.abs(val2))
	end
	return ree.sub(val, ree.mul(ree.floor(ree.div(val, val2)), val2))
end

function ree.root(val, val2)
	val,val2 = ree.correct(val),ree.correct(val2)
	if ree.eq(val2, 1) then
		return val
	end
	if ree.le(val2,ZERO) then
		return ree.recip(ree.root(val, ree.neg(val2)))
	end
	if ree.le(val2, 1) then
		return ree.pow(val, ree.recip(val2))
	end
	if ree.le(val, ZERO)and ree.isint(val2) and ree.eq(ree.mod(val2, 2), 1) then
		return ree.neg(ree.root(ree.neg(val), val2))
	end
	if ree.le(val, ZERO) then
		return NAN
	end
	if ree.eq(val, 1) then
		return {1, {1}}
	end
	if ree.eq(val, ZERO) then
		return ZERO
	end
	if ree.me(ree.max(val, val2), maxPOW) then
		if ree.me(val, val2)  then
			return val
		else
			return ZERO
		end
	end
	return ree.pow(10, ree.div(ree.log10(val), val2))
end

function ree.mul(val,val1)
	local x = ree.correct(val)
	local y= ree.correct(val1)
	if x[1]*y[1]==-1 then
		return ree.neg( ree.mul( ree.abs(x), ree.abs(y) ) )
	end
	if x[1] == -1 then
		return ree.mul(ree.abs(x),ree.abs(y))
	end
	if ree.eq(x,ZERO) or ree.eq(y,ZERO) then
		return ZERO
	end
	if ree.eq(y,{1,{1}}) then
		return x
	end
	if ree.me(ree.max(x,y),maxMUL) then
		return ree.max(x, y)
	end
	local n = ree.toNumber(x)*ree.toNumber(y)
	if n <= maxAllowed then
		return ree.correct(n)
	end
	return ree.pow(10,ree.add(ree.log10(x),ree.log10(y)))
end

function ree.floor(x)
	if ree.isint(x) then
		return x
	end
	return ree.correct(math.floor(ree.toNumber(x)))
end

function ree.ceil(x)
	if ree.isint(x) then
		return x
	end
	return ree.correct(math.ceil(ree.toNumber(x)))
end

function ree.div(val,val1)
	local x = ree.correct(val)
	local y = ree.correct(val1)
	if x[1]*y[1]==-1 then
		return ree.neg(ree.div(ree.abs(x), ree.abs(y)))
	end
	if x[1] == -1 then
		return ree.div(ree.abs(x),ree.abs(y))
	end
	if ree.eq(y, ZERO) then
		return NAN
	end
	if ree.eq(y,{1,{1}}) then
		return x
	end
	if ree.eq(x,ZERO) then
		return ZERO
	end
	if ree.me(ree.max(x,y),maxMUL) then
		if ree.me(x,y) then
			return x
		end
		return ZERO
	end
	local FILTER1 = ree.toNumber(x)/ree.toNumber(y)
	if FILTER1 <= maxAllowed then
		return ree.correct(FILTER1)
	end
	local qq = ree.pow(10, ree.sub(ree.log10(x),ree.log10(y)) )
	local qqw = ree.floor(qq)
	if ree.le(ree.sub(qq,qqw), 1e-9) then
		return qqw
	end
	return qq
end

function ree.add(x,y)
	x = ree.correct(x)
	y = ree.correct(y) 
	if x[1] == -1 then
		return ree.neg(ree.add(ree.neg(x), ree.neg(y)))
	end
	if y[1] == -1 then
		return ree.sub(x, ree.neg(y))
	end
	if ree.eq(x, ZERO) then
		return y
	end
	if ree.eq(y, ZERO) then
		return x
	end
	local p = ree.min(x,y)
	local q = ree.max(x,y)
	local a = nil
	if ree.me(q,maxADD) or ree.me(ree.div(q,p), maxInt) then
		a = q
	elseif q[2][2] == nil then
		a = ree.correct(ree.toNumber(x)+ree.toNumber(y))
	elseif q[2][2] == 1 then
		local b = nil
		if p[2][2] then
			b = p[2][1]
		else
			b = math.log10(p[2][1])
		end
		a = ree.correct({1, {b+math.log10(math.pow(10,q[2][1]-b)+1) , 1}})
	end
	return a
end

function ree.sub(x,y)
	x = ree.correct(x)
	y = ree.correct(y) 
	if x[1] == -1 then
		return ree.neg(ree.sub(ree.neg(x),ree.neg(y)))
	end
	if y[1] == -1 then
		return ree.add(x, ree.neg(y))
	end
	if ree.eq(x,y) then
		return ZERO
	end
	if ree.eq(y,ZERO) then
		return x
	end
	local p = ree.min(x,y)
	local q = ree.max(x,y)
	local FILTER2= ree.me(y,x)
	local FILTER1;
	if ree.me(q,maxADD) or ree.me(ree.div(q,p), maxADD) then
		FILTER1=q
		if FILTER2 then
			FILTER1 = ree.neg(FILTER1)
		end
	elseif q[2][2] == nil then
		FILTER1 = ree.correct(ree.toNumber(x)-ree.toNumber(y))
	elseif q[2][2] == 1 then
		local b = nil
		if p[2][2] then
			b = p[2][1]
		else
			b = math.log10(p[2][1])
		end
		local DIFF = q[2][1]-b
		if DIFF > 20 then
			FILTER1 = ree.max(x,y)
			if FILTER2 then
				return ree.neg(FILTER1)	
			end
			return FILTER1
		end
		FILTER1 = ree.correct({1, {b+math.log10(math.pow(10,q[2][1]-b)-1) , 1}})
		if FILTER2 then
			FILTER1 = ree.neg(FILTER1)	
		end
	end
	return FILTER1
end

function ree.sqrt(x)
	return ree.root(x,2)
end

function ree.log(x,y)
	y = y or 2.7182818284590452353602874
	return ree.div(ree.log10(x),ree.log10(y))
end

function ree.exp(x)
	return ree.pow(2.7182818284590452353602874, x)
end

function ree.maxabs(x,y)
	return ree.max(ree.abs(x),ree.abs(y))
end

function ree.eternitytoOmega(num)
	local new = {num[1], {}}
	new[2][1] = num[3]
	new[2][2] = (num[2]>=1) and num[2] or nil
	return new
end

function ree.pow10(x)
	return ree.pow(10,x)
end

function ree.gamma(x)
	x = ree.correct(x)
	if ree.me(x,maxPOW) then
		return x
	end
	if ree.me(x,maxADD) then
		return ree.exp(x)
	end
	if ree.me(x,maxInt) then
		return ree.exp(ree.mul(x,ree.sub(ree.log(x),1)))
	end
	if ree.leeq(x,171) then
		return ree.correct(fgamma(ree.toNumber(x)))
	end
	local q = x[2][1]
	if q>1 then
		local t=q-1
		local l=0.9189385332046727
		l+=(t+.5)*math.log(t)
		l-=t
		local n2 = t^2
		local np=t
		local lm=12*np
		local adj=1/lm
		local l2 = l+adj
		if (l2==l) then
			return ree.exp(l)
		end
		l=l2
		np*=2
		lm=360*np
		adj=1/lm
		l2=l-adj
		if (l2==l) then
			return ree.exp(l)
		end
		l=l2
		np*=n2
		lm=1260*np
		local lt=1/lm
		l+=lt
		np*=n2
		lm=1680*np
		lt=1/lm
		l-=lt
		return ree.exp(l)	
	end
	return ree.recip(x)
end

function fact(x) -- x!
	local amo = 1
	for i=1,x do
		amo *= i
	end
	return amo
end

function ree.fact(x)
	x = ree.correct(x)
	if ree.leeq(x, 170) then
		x = ree.toNumber(x)
		if x == math.floor(x) then
			return ree.correct(fact(x))
		end
		return ree.correct(fgamma(ree.toNumber(x)+1))
	end
	return ree.gamma(ree.add(x,1))
end

function ree.rand(min, max)
	local seed = math.random()
	local even = ree.sub(max, min)
	even = ree.mul(even, seed)
	return ree.add(even, min)
end

function ree.exporand(min, max)
	return ree.exp(ree.rand(ree.log(min), ree.log(max)))
end

function ree.toBigNum(val)
	val = ree.correct(val)
	local b = {}
	if #val[2] == 1 then
		return errorcorrection({val[2][1]*val[1],0})
	end
	if val[2][2] == 1 then
		return errorcorrection({1*val[1],val[2][1]})
	end
	if val[2][2] == 2 and math.log10(val[2][1]) <= 308 then
		return {1*val[1], 10^val[2][1]}
	end
	return {1*val[1], 3e308}
end

function ree.toScientific(x)
	x = ree.correct(x)
	if ree.le(x, 1000) then
		return ree.toNumber(x)
	end
	if ree.me(x,maxScientific) then
		return ree.toEs(x)
	end
	if ree.me(x, 'ee13.9') then
		return "1e" .. ree.toScientific(ree.log10(x))
	end
	local function Decimal(val, amo)
		local a = math.floor(val*10^amo)
		a = a/10^amo
		return a
	end
	local array = x[2]
	if array[2] == nil then
		local exp = math.log10(array[1])
		local b = 10^(exp-math.floor(exp))
		return Decimal(b,PrecisionDisplay) .. 'e' .. math.floor(exp)
	end
	if array[2] == 1 then
		local exp = array[1]
		local b = 10^(exp-math.floor(exp))
		return Decimal(b,PrecisionDisplay) .. 'e' .. math.floor(exp)
	end
end

function ree.toShortScientific(x)
	x = ree.correct(x)
	if ree.le(x,1000) then
		return ree.toNumber(x)
	end
	if ree.me(x,maxScientific) then
		return ree.toEs(x)
	end
	local x1 = x[1]
	local x2 = x[2]

	return string.rep("e", x2[2]) .. short(ree.toBigNum(x2[1]))
end

function ree.short(x)
	x = ree.correct(x)
	if ree.me(x,maxSuffix) then
		return ree.toShortScientific(x)
	end
	return short(ree.toBigNum(x))
end

function ree.toEnt(x)
	x = ree.correct(x)
	if x[2][3] then
		if x[2][3] > 1 or x[2][1] > 308 or x[2][2] > 1 then
			return ree.toShortHyperE(x)
		end
		x[2][2] = 10^x[2][1]
		x[2][3] = nil
	end
	local part = "E(" .. x[2][2] .. ")"
	if x[1] == -1 then
		part = "-" .. part
	end
	return part .. x[2][1]
end

function ree.toShortEnt(x)
	x = ree.correct(x)
	if x[2][3] then
		if x[2][3] > 1 or x[2][1] > 308 or x[2][2] > 1 then
			return ree.toShortHyperE(x)
		end
		x[2][2] = 10^x[2][1]
		x[2][3] = nil
	end
	local part = "E(" .. ree.short(x[2][2]) .. ")"
	if x[1] == -1 then
		part = "-" .. part
	end
	return part .. ree.short(x[2][1])
end

function ree.toEs(x)
	x = ree.correct(x)
	if #x[2] > 2 then
		return ree.toEnt(x)
	end
	if x[2][2] == nil then
		return ree.short(x)
	end
	if x[2][2] > maxEs then
		return ree.toEnt(x)
	end
	if x[1] == -1 then
		return "-" .. ree.toEs(ree.abs(x))
	end
	local function Decimal(val, amo)
		local a = math.floor(val*10^amo)
		a = a/10^amo
		return a
	end
	local estring = string.rep("e", x[2][2])
	return estring .. Decimal(x[2][1],4)
end

function ree.toShortEs(x)
	x = ree.correct(x)
	if #x[2] > 2 then
		return ree.toShortEnt(x)
	end
	if x[2][2] == nil then
		return ree.short(x)
	end
	if x[2][2] > maxEs then
		return ree.toShortEnt(x)
	end
	if x[1] == -1 then
		return "-" .. ree.toShortEs(ree.abs(x))
	end
	local function Decimal(val, amo)
		local a = math.floor(val*10^amo)
		a = a/10^amo
		return a
	end
	local estring = string.rep("e", x[2][2])
	return estring .. ree.short(Decimal(x[2][1],4))
end

function ree.toHyperE(x)
	x = ree.correct(x)
	if x[1] == -1 then
		return "-" .. ree.toHyperE(ree.abs(x))
	end
	if ree.le(x,maxInt) then
		return ree.short(x)
	end
	if ree.le(x,maxADD) then
		return "E" .. x[2][1]
	end
	local function Decimal(val, amo)
		local a = math.floor(val*10^amo)
		a = a/10^amo
		return a
	end
	local str = "E" ..  Decimal(x[2][1],PrecisionDisplay).."#" .. x[2][2]
	for i=3,#x[2] do
		str ..= "#" .. x[2][i]+1
	end
	return str
end

function ree.toShortHyperE(x)
	x = ree.correct(x)
	if x[1] == -1 then
		return "-" .. ree.toShortHyperE(ree.abs(x))
	end
	if ree.le(x,maxInt) then
		return ree.short(x)
	end
	if ree.le(x,maxADD) then
		return "E" .. ree.short(x[2][1])
	end
	local function Decimal(val, amo)
		local a = math.floor(val*10^amo)
		a = a/10^amo
		return a
	end
	local str = "E" ..  ree.short(Decimal(x[2][1],PrecisionDisplay)).."#" .. ree.short(x[2][2])
	for i=3,#x[2] do
		str ..= "#" .. ree.short(x[2][i]+1)
	end
	return str
end

function ree.lambertw(x)
	x = ree.correct(x)
	if ree.leeq(x,1e308) then
		return f_lambertw(ree.toNumber(x))
	end
	if ree.me(x, maxPOW) then
		return x
	end
	if ree.me(x, maxMUL) then
		return ree.log10(x)
	end
	return Hlambertw(x)
end

function ree.slog(r,base)
	local x = copytab(ree.correct(r))
	base = ree.toOmega(base)
	if ree.le(x, ZERO) then
		return {-1,{1}}
	end
	if ree.eq(x,ONE)  then
		return ZERO
	end
	if ree.eq(x,base) then
		return ONE
	end
	if ree.le(base, math.exp(1/2.7182818284)) then
		return x
	end
	if ree.me(ree.max(x,base),{1,{10000000000, 8, maxInt}}) then
		if ree.me(x,base) then
			return x
		end
		return ZERO
	end
	if ree.me(ree.max(x,base), maxPOW) then
		if ree.me(x,base) then
			x[2][3] -= 1
			return ree.sub(x,x[2][2])
		end
		return ZERO
	end
	local q =0
	local t = (x[2][2] or 0) - (base[2][2] or 0)
	if t>3 then
		local p = t-3
		q += p
		x[2][2] -= p
	end
	for i=1,99 do
		if ree.le(x, ZERO) then
			x = ree.pow(base,x)
			q-=1
		else if ree.leeq(x,1) then
				return ree.toOmega(q+ree.toNumber(x)-1)	
			else 
				q += 1
				x = ree.log(x,base)
			end
		end
	end
	if ree.me(x, 10) then
		return q
	end
end

function ree.tetrate(x,y)
	x = ree.correct(x)
	y = ree.correct(y)
	if ree.le(y,-2) then
		return NAN
	end
	if ree.eq(x,ZERO) then
		if ree.eq(y,0) then
			return NAN
		end
		if ree.eq(ree.mod(y,2),0) then
			return ZERO
		end
		return {1,{1}}
	end
	if ree.eq(x,{1,{1}}) then
		if ree.eq(y, {-1,{1}}) then
			return NAN
		end
		return {1,{1}}
	end
	if ree.eq(y, {-1,{1}}) then
		return ZERO
	end
	if ree.eq(y, 0) then
		return {1,{1}}
	end
	if ree.eq(y, 1) then
		return x
	end
	if ree.eq(y,2) then
		return ree.pow(x,x)
	end
	if ree.eq(x,2) then
		if ree.eq(y,3) then
			return ree.fromNumber(16)
		end
		if ree.eq(y,4) then
			return ree.fromNumber(65536)
		end
	end
	local max = ree.max(x,y)
	if ree.me(max, {1,{10000000000, 8, maxInt}}) then
		return max
	end
	if ree.me(x, maxPOW) or ree.me(y, maxInt) then
		if ree.le(x, math.exp(1/2.7182818284)) then
			local nel = ree.neg(ree.log(x))
			return ree.div(ree.lambertw(nel), nel)
		end
		local q = copytab(ree.add(ree.slog(x,10),y))
		q[2][3] = (y[2][3] or 0)+1
		return ree.correct(q)
	end
	local yo = ree.toNumber(y)
	local fo = math.floor(yo)
	local ro = ree.pow(x, yo-fo)
	local mo = maxADD
	local lo = NAN
	local count = 0
	for i=1,100 do
		if not(fo~=0 and ree.le(ro,mo)) then break end
		count +=1
		if fo>0 then
			ro = ree.pow(x,ro)
			if ree.eq(lo,ro) then
				fo=0
				break
			end
			lo=ro
			fo -= 1
		else
			ro = ree.log(ro,x)
			if ree.eq(lo,ro) then
				fo=0
				break
			end
			lo=ro
			fo += 1
		end
	end
	if count == 100 or ree.le(x,math.exp(1/2.7182818284)) then
		fo = 0
	end
	ro[2][2] = ro[2][2] and ro[2][2]+fo or fo
	return ree.correct(ro)
end

function ree.pentate(x,y)
	x = ree.correct(x)
	y = ree.correct(y)
	if ree.le(y,-2) then
		return NAN
	end
	if ree.eq(x,ZERO) then
		if ree.eq(y,0) then
			return NAN
		end
		if ree.eq(ree.mod(y,2),0) then
			return ZERO
		end
		return {1,{1}}
	end
	if ree.eq(x,{1,{1}}) then
		if ree.eq(y, {-1,{1}}) then
			return NAN
		end
		return {1,{1}}
	end
	if ree.eq(y, {-1,{1}}) then
		return ZERO
	end
	if ree.eq(y, 0) then
		return {1,{1}}
	end
	if ree.eq(y, 1) then
		return x
	end
	if ree.eq(y,2) then
		return ree.tetrate(x,x)
	end
	if ree.eq(x,2) then
		if ree.eq(y,3) then
			return ree.fromNumber(65536)
		end
	end
	local max = ree.max(x,y)
	if ree.me(max, {1,{10000000000, 8, maxInt}}) then
		return max
	end
	if ree.me(x, maxPOW) or ree.me(y, maxInt) then
		if ree.le(x, math.exp(1/2.7182818284)) then
			local nel = ree.neg(ree.log(x))
			return ree.div(ree.lambertw(nel), nel)
		end
		local q = copytab(ree.add(ree.slog(x,10),y))
		q[2][3] = (y[2][3] or 0)
		q[2][4] = (y[2][4] or 0)+1
		return ree.correct(q)
	end
	local yo = ree.toNumber(y)
	local fo = math.floor(yo)
	local ro = ree.pow(x, yo-fo)
	local mo = maxADD
	local lo = NAN
	local count = 0
	for i=1,100 do
		if not(fo~=0 and ree.le(ro,mo)) then break end
		count +=1
		if fo>0 then
			ro = ree.tetrate(x,ro)
			if ree.eq(lo,ro) then
				fo=0
				break
			end
			lo=ro
			fo -= 1
		else
			ro = ree.log(ro,x)
			if ree.eq(lo,ro) then
				fo=0
				break
			end
			lo=ro
			fo += 1
		end
	end
	if count == 100 or ree.le(x,math.exp(1/2.7182818284)) then
		fo = 0
	end
	ro[2][3] = ro[2][3] and ro[2][3]+fo or fo
	return ree.correct(ro)
end

function ree.arrow(x,y,z) --oh ye
	x = ree.correct(x)
	z = ree.correct(y)
	if y == 0 then
		return ree.mul(x,y)
	end
	if y>ArrowLimit then 
		if ree.me(x,1) and ree.me(z,1) then
			return INF
		end
	end
	if ree.eq(y,1) then 
		return x 
	end
	if ree.eq(x,0) then
		if y == 2 and ree.eq(y,0) then return NAN end
		if y == 1 and ree.eq(y,0) then return ONE end
		return ZERO
	end
	if ree.le(x,0) or ree.le(y,0) then
		if y>=2 then
			return NAN
		end
		if y==1 then return ree.pow(x,y) end
	end
	if y == 2 then
		return ree.tetrate(x,z)
	end
end

function ree.lbencode(onum)
	onum = ree.correct(onum)
	if ree.eq(onum,0) then
		return 0
		-- For maximum performance, you do not need to encode 0.
	end
	local sign = onum[1]
	onum = onum[2]
	-- #onum
	local amo = #onum 
	-- convert to float rn??
	if amo == 1 then
		-- mode 0: Native Float
		return sign * math.floor(math.log10((onum[1] + 1)) * 6.26775e14)
	elseif amo == 2 and onum[2] < 4 then
		-- mode 1: Native BigNum
		-- mode 2: Native Post-BigNum
		-- mode 3: Native EternityNum
		return sign * (math.floor(math.log10((onum[1] + 1)) * 6.26775e14) + onum[2]*1e16)
	elseif amo == 2 and onum[2] <= 9999 then
		-- mode 4: Native Big EternityNum Numbers
		local cnum = 4e16
		cnum += math.log10((onum[1] + 1)) * 6.26775e8
		cnum += onum[2] * 1e10
		return sign * cnum
	elseif amo == 2 then
		-- mode 5: Native Extreme EternityNum Numbers
		local cnum = 5e16
		cnum += math.log10((onum[2] + (math.log10(onum[1]) / 16) + 1)) * 6.26775e14
		return sign * cnum
	elseif amo == 3 and onum[3] == 1 then
		-- mode 6: Beyond EternityNum
		local cnum = 6e16
		cnum += math.log10((onum[2] + (math.log10(onum[1]) / 16) + 1)) * 6.26775e14
		return sign * cnum
	elseif amo == 3 and onum[3] == 2 then
		-- mode 7: Post-EternityNum
		local cnum = 7e16
		cnum += math.log10((onum[2] + (math.log10(onum[1]) / 16) + 1)) * 6.26775e14
		return sign * cnum
	elseif amo == 3 and onum[3] < 9999 then
		-- mode 8: Pentation Empire
		local cnum = 8e16
		cnum += math.log10((onum[2] + (math.log10(onum[1]) / 16) + 1)) * 6.26775e8
		cnum += onum[3] * 1e10
		return sign * cnum
	elseif amo == 3 then
		-- mode 9: Ultra Pentation
		local cnum = 9e16
		cnum += math.log10((onum[3] + (math.log10(onum[2]+1) / 16) + 1)) * 6.26775e14
		return sign * cnum
	elseif amo == 4 then
		-- mode 10: Big Number Territory
		local cnum = 1e17
		cnum += math.log10((onum[4] + (math.log10(onum[3]+1) / 16) + 1)) * 6.26775e14
		return sign * cnum
	elseif amo == 5 then
		-- mode 11: I Do Not Konw
		local cnum = 1.1e17
		cnum += math.log10((onum[5] + (math.log10(onum[4]+1) / 16) + 1)) * 6.26775e14
		return sign * cnum
	elseif amo > 5 and amo < 917 then
		-- good until 916 arrays
		local cnum = amo*1e16 + 6e16
		cnum += math.log10((onum[amo] + (math.log10(onum[amo - 1]+1) / 16) + 1)) * 6.26775e14
		return sign * cnum
	else
		return sign * 9223372036854775808
	end
end

function ree.lbdecode(int)
	if int == 0 then return {1, {0}} end
	local sign = math.sign(int)
	int = math.abs(int)
	local mode = math.floor(int / 1e16)
	if mode>=3 then
		int -= 1
	end
	if mode == 0 then
		return {sign, {10^(int / 6.26775e14) - 1}}
	elseif mode < 4 then
		return {sign, {10^(math.fmod(int, 1e16) / 6.26775e14) - 1, mode}}
	elseif mode == 4 then
		local remainder = math.fmod(int, 1e10)
		return {sign, {10^(remainder / 6.26775e8) - 1, math.floor((int - 4e16) / 1e10)}}
	elseif mode == 5 then
		local remainder = math.fmod(int, 1e16)
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = 10^(math.fmod(arrows, 1)*16)
		return {sign, {arg1, math.floor(arrows)}}
	elseif mode == 6 then
		local remainder = math.fmod(int, 1e16)
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = 10^(math.fmod(arrows, 1)*16)
		return {sign, {arg1, math.floor(arrows), 1}}
	elseif mode == 7 then
		local remainder = math.fmod(int, 1e16)
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = 10^(math.fmod(arrows, 1)*16)
		return {sign, {arg1, math.floor(arrows), 2}}
	elseif mode == 8 then
		local arg3 = math.floor((int-8e16) / 1e10)
		local remainder = math.fmod(int, 1e10) * 1e6
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = 10^(math.fmod(arrows, 1)*16)
		return {sign, {arg1, math.floor(arrows), math.floor(arg3)}}
	elseif mode == 9 then
		local remainder = math.fmod(int, 1e16)
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = 10^(math.fmod(arrows, 1)*16)
		return {sign, {1, math.floor(arg1), math.floor(arrows)}}
	elseif mode == 10 then
		local remainder = math.fmod(int, 1e16)
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = 10^(math.fmod(arrows, 1)*16)
		local hixd = {sign, {1, 0, math.floor(arg1), math.floor(arrows)}}
		if hixd[2][4] == 0 then
			table.remove(hixd[2], 4)
		end
		return hixd
	else
		local zeros = mode - 10
		local remainder = math.fmod(int, 1e16)
		local arrows = 10^(remainder / 6.26775e14) - 1
		local arg1 = maxInt^(math.fmod(arrows, 1))
		local xd = {1, 0}
		for i=1,zeros do
			table.insert(xd, 0)
		end
		table.insert(xd, math.floor(arg1))
		table.insert(xd, math.floor(arrows))
		if xd[zeros + 4] == 0 then
			table.remove(xd)
		end
		return {sign, xd}
	end
end

--bignum part ; )
function errorcorrection(bnum)	
	local signal = "+"
	if bnum[1] == 0 then
		return {0, 0}
	end
	if bnum[1] < 0 then
		signal = "-"
	end
	if signal == "-" then
		bnum[1] = bnum[1] * -1
	end
	local signal2 = "+"
	if bnum[2] < 0 then
		signal2 = "-"
		bnum[2] = bnum[2] * -1
	end
	if math.fmod(bnum[2], 1) > 0 and signal2 == "-" then
		bnum[1] = bnum[1] * (10^ (1 - math.fmod(bnum[2], 1)))
		bnum[2] = math.floor(bnum[2]) + 1
	elseif math.fmod(bnum[2], 1) > 0 and signal2 == "+"  then
		bnum[1] = bnum[1] * (10^  math.fmod(bnum[2], 1))
		bnum[2] = math.floor(bnum[2])
	end
	if signal2 == "-" then
		bnum[2] = bnum[2] * -1		
	end
	local DgAmo = math.log10(bnum[1])
	DgAmo = math.floor(DgAmo)
	bnum[1] = bnum[1] / 10^DgAmo
	bnum[2] = bnum[2] + DgAmo	
	bnum[2] = math.floor(bnum[2])
	if signal == "-" then
		bnum[1] = bnum[1] * -1		
	end
	return bnum
end	

function bnumtostr(bnum)	
	return tostring(bnum[1]) .. "e" .. tostring(bnum[2])
end

function bnumtofloat(bnum)	
	return tonumber(bnumtostr(bnum))
end

function commas(Value)
	if Value < 1e3 then 
		return Value
	end
	local Number
	local Formatted = math.floor(Value * 100) / 100
	if Value < 10^13 then
		while (Number ~= 0) do
			Formatted, Number = string.gsub(Formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
		end 
		return Formatted
	elseif Value < 10^26 then
		local Formatted2 = math.floor(Value / 10^12)
		Formatted = math.fmod(Value, 10^12)
		while Number ~= 0 do  
			Formatted2, Number = string.gsub(Formatted2, "^(-?%d+)(%d%d%d)", '%1,%2')
		end 
		Number = nil
		while Number ~= 0 do   
			Formatted, Number = string.gsub(Formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
		end 
		local TpFormatted = math.fmod(Value, 10^12)
		local String = Formatted2 .. ","
		if TpFormatted == 0 then
			String ..= "000,000,000,000"
		elseif TpFormatted < 10 then
			String ..= "000,000,000,00"
		elseif TpFormatted < 100 then
			String ..= "000,000,000,0"
		elseif TpFormatted < 1000 then
			String ..= "000,000,000,"
		elseif TpFormatted < 10000 then
			String ..= "000,000,00"
		elseif TpFormatted < 100000 then
			String ..= "000,000,0"
		elseif TpFormatted < 1000000 then
			String ..= "000,000,"
		elseif TpFormatted < 10000000 then
			String ..= "000,00"
		elseif TpFormatted < 100000000 then
			String ..= "000,0"
		elseif TpFormatted < 1000000000 then
			String ..= "000,"
		elseif TpFormatted < 10000000000 then
			String ..= "00"
		elseif TpFormatted < 100000000000 then
			String ..= "0"
		end
		if TpFormatted > 0 then
			String ..= Formatted
		end
		return String
	else
		return "9,999,999,999,999,999,999,999,999,999+"
	end
end

function short(bnum)
	local SNumber = bnum[2]
	local SNumber1 = bnum[1]
	local leftover = math.fmod(SNumber, 3)
	SNumber = math.floor(SNumber / 3)
	SNumber = SNumber - 1
	if SNumber <= -1 then
		return math.floor(bnumtofloat(bnum)*100 + 0.000000001)/100	
	end
	local FirstOnes = {"", "U","D","T","q","Q","s","S","O","N"}
	local SecondOnes = {"", "d","v","t","qg","Qg","sg","Sg","o","n"}
	local ThirdOnes = {"", "C", "Du","Tr","Qa","Qi","Se","Si","Ot","Ni"}
	local MultOnes = {"", "Mi","Mc","Na","Pi","Fm","At","Zp","Yc", "Xo", "Ve", "Me", "Due", "Tre", "Te", "Pt", "He", "Hp", "Oct", "En", "Ic", "Mei", "Dui", "Tri", "Teti", "Pti", "Hei", "Hp", "Oci", "Eni", "Tra","TeC","MTc","DTc","TrTc","TeTc","PeTc","HTc","HpT","OcT","EnT","TetC","MTetc","DTetc","TrTetc","TeTetc","PeTetc","HTetc","HpTetc","OcTetc","EnTetc","PcT","MPcT","DPcT","TPCt","TePCt","PePCt","HePCt","HpPct","OcPct","EnPct","HCt","MHcT","DHcT","THCt","TeHCt","PeHCt","HeHCt","HpHct","OcHct","EnHct","HpCt","MHpcT","DHpcT","THpCt","TeHpCt","PeHpCt","HeHpCt","HpHpct","OcHpct","EnHpct","OCt","MOcT","DOcT","TOCt","TeOCt","PeOCt","HeOCt","HpOct","OcOct","EnOct","Ent","MEnT","DEnT","TEnt","TeEnt","PeEnt","HeEnt","HpEnt","OcEnt","EnEnt","Hect", "MeHect"}
	if bnum[2] == 1/0 then
		if bnum[1] < 0 then
			return "-Infinity"
		else
			return "Infinity"
		end
	end
	-- suffix part
	if SNumber == 0 then
		return commas(bnumtofloat(bnum))
	elseif SNumber == 1 then
		return math.floor(SNumber1 * 10^leftover * 100 + 0.000000001)/100 .. "M"
	elseif SNumber == 2 then
		return math.floor(SNumber1 * 10^leftover * 100 + 0.000000001)/100 .. "B"
	end
	local txt = ""	
	local function suffixpart(n)		
		local Hundreds = math.floor(n/100)
		n = math.fmod(n, 100)
		local Tens = math.floor(n/10)
		n = math.fmod(n, 10)
		local Ones = math.floor(n/1)		
		txt = txt .. FirstOnes[Ones + 1]
		txt = txt .. SecondOnes[Tens + 1]
		txt = txt .. ThirdOnes[Hundreds + 1]		
	end
	local function suffixpart2(n)
		if n > 0 then
			n = n + 1
		end
		if n > 1000 then
			n = math.fmod(n, 1000)
		end
		local Hundreds = math.floor(n/100)
		n = math.fmod(n, 100)
		local Tens = math.floor(n/10)
		n = math.fmod(n, 10)
		local Ones = math.floor(n/1)		
		txt = txt .. FirstOnes[Ones + 1]
		txt = txt .. SecondOnes[Tens + 1]
		txt = txt .. ThirdOnes[Hundreds + 1]		
	end	
	if SNumber < 1000 then
		suffixpart(SNumber)
		return math.floor(SNumber1 * 10^leftover * 100 + 0.000000001)/100 .. txt
	end	
	for i = #MultOnes,0,-1 do
		if SNumber >= 10^(i*3) then
			suffixpart2(math.floor(SNumber / 10^(i*3))- 1)
			txt = txt .. MultOnes[i+1]			
			SNumber = math.fmod(SNumber, 10^(i*3))
		end
	end
	return math.floor(SNumber1 * 10^leftover * 100 + 0.000000001)/100 .. txt
end

-- Making it easier for SamirDevs to use this for OperatorSim lol.

function ree.onflt(onum)
	return ree.toNumber(onum)
end

function ree.flton(flt)
	return ree.toOmega(flt)
end

function ree.onstr(onum)
	return ree.toString(onum)
end

function ree.stron(str)
	return ree.toOmega(str)
end

function ree.equal(onum1,onum2)
	return ree.eq(onum1,onum2)
end

function ree.moreequal(onum1,onum2)
	return ree.meeq(onum1,onum2)
end

function ree.lessequal(onum1,onum2)
	return ree.leeq(onum1,onum2)
end

function ree.more(onum1,onum2)
	return ree.me(onum1,onum2)
end

function ree.less(onum1,onum2)
	return ree.le(onum1,onum2)
end

function ree.abbreviate(onum)
	onum = ree.correct(onum)
	if ree.eq(onum,{1,{0}}) then
		return "0"
	elseif ree.le(onum, {1, {0.000000001}}) then
		return "1 / " .. ree.short(ree.div(1, onum))
	elseif ree.le(onum,maxSuffix) then
		return ree.short(onum)
	elseif ree.le(onum,maxScientific) then
		return ree.toShortScientific(onum)
	elseif ree.le(onum,{1,maxEs,1}) then
		return ree.toShortEs(onum) 
	elseif ree.le(onum,{1,1e306,1}) then
		return ree.toShortEnt(onum)
	else
		return ree.toShortHyperE(onum)
	end
end

return ree]]></ProtectedString>
						<int64 name="SourceAssetId">10415532047</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXBFCB5F90EEE8411AB1424AE032A538C4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Bnum</string>
						<string name="ScriptGuid">{4EB774D7-55D3-4EC2-AE28-20D879B599B8}</string>
						<ProtectedString name="Source"><![CDATA[local xN = {}
function xN.short(num)
	local bnum = xN.convert(num)
	bnum = xN.errorcorrection(bnum)
	local SNumber = bnum[2]
	local SNumber1 = bnum[1]
	local leftover = math.fmod(SNumber, 3)
	SNumber = math.floor(SNumber / 3)
	SNumber = SNumber - 1
	if SNumber <= -1 then
		return math.floor(xN.bnumtofloat(bnum) * 100) / 100	
	end
	local FirstOnes = {"", "U","D","T","Qd","Qn","Sx","Sp","Oc","No"}
	local SecondOnes = {"", "De","Vt","Tg","qg","Qg","sg","Sg","Og","Ng"}
	local ThirdOnes = {"", "Ce", "Du","Tr","Qa","Qi","Se","Si","Ot","Ni"}
	local MultOnes = {"", "Mi","Mc","Na","Pi","Fm","At","Zp","Yc", "Xo", "Ve", "Me", "Due", "Tre", "Te", "Pt", "He", "Hp", "Oct", "En", "Ic", "Mei", "Dui", "Tri", "Teti", "Pti", "Hei", "Hp", "Oci", "Eni", "Tra","TeC","MTc","DTc","TrTc","TeTc","PeTc","HTc","HpT","OcT","EnT","TetC","MTetc","DTetc","TrTetc","TeTetc","PeTetc","HTetc","HpTetc","OcTetc","EnTetc","PcT","MPcT","DPcT","TPCt","TePCt","PePCt","HePCt","HpPct","OcPct","EnPct","HCt","MHcT","DHcT","THCt","TeHCt","PeHCt","HeHCt","HpHct","OcHct","EnHct","HpCt","MHpcT","DHpcT","THpCt","TeHpCt","PeHpCt","HeHpCt","HpHpct","OcHpct","EnHpct","OCt","MOcT","DOcT","TOCt","TeOCt","PeOCt","HeOCt","HpOct","OcOct","EnOct","Ent","MEnT","DEnT","TEnt","TeEnt","PeEnt","HeEnt","HpEnt","OcEnt","EnEnt","Hect", "MeHect"}
	if bnum[2] == 1/0 then
		if bnum[1] < 0 then
			return "-Infinity"
		else
			return "Infinity"
		end
	end
	if SNumber == 0 then
		return math.floor(SNumber1 * 10^leftover * 100)/100 .. "k"
	elseif SNumber == 1 then
		return math.floor(SNumber1 * 10^leftover * 100)/100 .. "M"
	elseif SNumber == 2 then
		return math.floor(SNumber1 * 10^leftover * 100)/100 .. "B"
	end
	local txt = ""
	local function suffixpart(n)
		local Hundreds = math.floor(n/100)
		n = math.fmod(n, 100)
		local Tens = math.floor(n/10)
		n = math.fmod(n, 10)
		local Ones = math.floor(n/1)
		txt = txt .. FirstOnes[Ones + 1]
		txt = txt .. SecondOnes[Tens + 1]
		txt = txt .. ThirdOnes[Hundreds + 1]
	end
	local function suffixpart2(n)
		if n > 0 then
			n = n + 1
		end
		if n > 1000 then
			n = math.fmod(n, 1000)
		end
		local Hundreds = math.floor(n/100)
		n = math.fmod(n, 100)
		local Tens = math.floor(n/10)
		n = math.fmod(n, 10)
		local Ones = math.floor(n/1)
		txt = txt .. FirstOnes[Ones + 1]
		txt = txt .. SecondOnes[Tens + 1]
		txt = txt .. ThirdOnes[Hundreds + 1]
	end
	if SNumber < 1000 then
		suffixpart(SNumber)
		return math.floor(SNumber1 * 10^leftover * 100)/100 .. txt
	end
	for i=#MultOnes,0,-1 do
		if SNumber >= 10^(i*3) then
			suffixpart2(math.floor(SNumber / 10^(i*3))- 1)
			txt = txt .. MultOnes[i+1]
			SNumber = math.fmod(SNumber, 10^(i*3))
		end
	end
	return math.floor(SNumber1 * 10^leftover * 100)/100 .. txt
end
function xN.strtobnum(str)
	local Synapse = string.find(str, "e")
	return {tonumber(string.sub(str, 1, Synapse-1)), tonumber(string.sub(str, Synapse+1))}
end
function xN.bnumtofloat(bnum)	
	return tonumber(xN.bnumtostr(bnum))
end
function xN.convert(str)	
	if tonumber(str) == nil then
		local V,Uw = pcall(function()
			return xN.strtobnum(str) 
		end)
		if V then
			return xN.strtobnum(str)
		else
			return "0"
		end
	end
	if type(str) == "number" then
		if tonumber(str) == 1/0 or  tonumber(str) == -1/0 then
			return {1, 1.797693e308}
		end
	end
	if tonumber(str) == 1/0 or  tonumber(str) == -1/0 then
		return xN.strtobnum(str)
	elseif tostring(tonumber(str)) == "nil" then
		return xN.strtobnum(str)
	else
		return xN.floattobnum(tonumber(str))
	end
end
function xN.new(man,exp)	
	return {man, exp}
end
function xN.floattobnum(float)
	local ZeN = tostring(float)
	local Synapse = string.find(ZeN, "+")	
	if Synapse then
		return xN.strtobnum(string.sub(ZeN, 1, Synapse-1) .. string.sub(ZeN, Synapse+1))
	elseif string.find(ZeN, "e") then
		return xN.strtobnum(ZeN)
	else
		return xN.errorcorrection(xN.strtobnum(ZeN .. "e0")	)
	end	
end
function xN.bnumtostr(bnum)	
	return tostring(bnum[1]) .. "e" .. tostring(bnum[2])
end
function xN.errorcorrection(bnum)	
	local signal = "+"
	if bnum[1] == 0 then
		return {0, 0}
	end
	if bnum[1] < 0 then
		signal = "-"
	end
	if signal == "-" then
		bnum[1] = bnum[1] * -1
	end
	local signal2 = "+"
	if bnum[2] < 0 then
		signal2 = "-"
		bnum[2] = bnum[2] * -1
	end
	if math.fmod(bnum[2], 1) > 0 and signal2 == "-" then
		bnum[1] = bnum[1] * (10^ (1 - math.fmod(bnum[2], 1)))
		bnum[2] = math.floor(bnum[2]) + 1
	elseif math.fmod(bnum[2], 1) > 0 and signal2 == "+"  then
		bnum[1] = bnum[1] * (10^  math.fmod(bnum[2], 1))
		bnum[2] = math.floor(bnum[2])
	end
	if signal2 == "-" then
		bnum[2] = bnum[2] * -1		
	end
	local DgAmo = math.log10(bnum[1])
	DgAmo = math.floor(DgAmo)
	bnum[1] = bnum[1] / 10^DgAmo
	bnum[2] = bnum[2] + DgAmo	
	bnum[2] = math.floor(bnum[2])
	if signal == "-" then
		bnum[1] = bnum[1] * -1		
	end
	return bnum
end	
function xN.div(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local bnum3 = xN.new(0, 0)
	bnum3[1] = bnum1[1] / bnum2[1]
	bnum3[2] = bnum1[2] - bnum2[2]
	bnum3 = xN.errorcorrection(bnum3)
	return bnum3
end
function xN.mul(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local bnum3 = xN.new(0, 0)
	bnum3[1] = bnum1[1] * bnum2[1]
	bnum3[2] = bnum1[2] + bnum2[2]
	bnum3 = xN.errorcorrection(bnum3)
	return bnum3
end
function xN.log10(bnum)
	local LogTen = bnum[2] + math.log10(bnum[1])
	return xN.errorcorrection(xN.new(LogTen, 0))
end
function xN.eq(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	if bnum1[1] == bnum2[1] then
		if bnum1[2] == bnum2[2] then
			return true
		end
	end
	return false
end
function xN.le(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local signal = "+"
	local signal2 = "+"
	if bnum1[1] < 0 then
		signal = "-"
	end
	if bnum2[1] < 0 then
		signal2 = "-"
	end
	if signal == "+" and signal2 == "-" then
		return false
	elseif signal == "-" and signal2 == "+" then
		return true
	elseif signal == "-" and signal2 == "-" then
		if bnum1[2] > bnum2[2] then
			return true
		end
		if bnum1[2] < bnum2[2] then
			return false
		end
		if bnum1[1] < bnum2[1] then
			return true
		end	
	elseif signal == "+" and signal2 == "+" then
		if bnum1[2] < bnum2[2] then
			return true
		end
		if bnum1[2] > bnum2[2] then
			return false
		end
		if bnum1[1] < bnum2[1] then
			return true
		end	
	end	
	return false
end
function xN.me(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local signal = "+"
	local signal2 = "+"
	if bnum1[1] < 0 then
		signal = "-"
	end
	if bnum2[1] < 0 then
		signal2 = "-"
	end
	if signal == "+" and signal2 == "-" then
		return true
	elseif signal == "-" and signal2 == "+" then
		return false
	elseif signal == "-" and signal2 == "-" then
		if bnum1[2] < bnum2[2] then
			return true
		end 
		if bnum1[2] < bnum2[2] then
			return false
		end
		if bnum1[1] > bnum2[1] then
			return true
		end	
	elseif signal == "+" and signal2 == "+" then
		if bnum1[2] > bnum2[2] then
			return true
		end
		if bnum1[2] < bnum2[2] then
			return false
		end
		if bnum1[1] > bnum2[1] then
			return true
		end
	end
	return false
end
function xN.leeq(bnum1, bnum2)
	local Se1 = xN.eq(bnum1,bnum2)
	local Se2 = xN.le(bnum1,bnum2)
	if Se1 or Se2 then
		return true
	end
	return false
end
function xN.meeq(num1, num2)
	local bnum1 = xN.convert(num1)
	local bnum2 = xN.convert(num2)
	local Se1 = xN.eq(bnum1,bnum2)
	local Se2 = xN.me(bnum1,bnum2)
	if Se1 or Se2 then
		return true
	end
	return false
end
function xN.add(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local bnum3 = xN.new(0,0)
	local Diff = bnum2[2] - bnum1[2]
	if Diff > 20 then
		return bnum2
	elseif Diff < - 20 then
		return bnum1
	else
		bnum3[2] = bnum1[2]
		bnum3[1] = bnum1[1] + (bnum2[1] * 10^Diff)
	end
	bnum3 = xN.errorcorrection(bnum3)
	return bnum3
end
function xN.sub(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local bnum3 = xN.new(0,0)
	local Diff = bnum2[2] - bnum1[2]
	if Diff > 20 then
		bnum3 = xN.new(bnum1[1] * -1, bnum2[2])
	elseif Diff < - 20 then
		return bnum1
	else
		bnum3[2] = bnum1[2]
		bnum3[1] = bnum1[1] - (bnum2[1] * 10^Diff)
	end
	bnum3 = xN.errorcorrection(bnum3)
	return bnum3
end
function xN.pow(bnum1, bnum2)
	if bnum1[1] < 0 then
		return {1, "Unsupported"}
	end
	if bnum1[1] == 0 and bnum2[2] == 0 then
		warn("I agree that 0 ^ 0 is 0.5")
		return {0.5, 0}
	elseif bnum2[1] == 0 then
		return {1, 0}
	elseif bnum1[1] == 0 then
		return {0, 0}	
	end	
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local bnum3 = {0, 0}
	local N = xN.log10(bnum1)
	N = xN.bnumtofloat(N)	
	N = N * xN.bnumtofloat(bnum2)
	bnum3[2] = N
	bnum3[1] = 1
	return xN.errorcorrection(bnum3)
end
function xN.doublepow(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)

	return xN.pow(bnum1, xN.pow(bnum2, bnum2))
end
function xN.sqrt(bnum1)
	bnum1 = xN.errorcorrection(bnum1)	
	return xN.pow(bnum1, {5, -1})
end
function xN.pi()
	return {3.141592653589793238462643383279502884197169399375105820974, 0}
end
function xN.e()
	return {2.718281828459045235360287471352662497757247093699959574966, 0}
end
function xN.gr()
	return {1.618033988749894848204586834365638117720309179805762862135, 0}
end
function xN.two()
	return {2, 0}
end
function xN.ten()
	return {1, 1}
end
function xN.logx(bnum1, bnum2)
	local b = xN.bnumtofloat(bnum2)
	local LogTen = bnum1[2] + math.log10(bnum1[1])
	LogTen = LogTen / math.log10(b)	
	return xN.errorcorrection(xN.new(LogTen, 0))
end
function xN.log(bnum)
	local b = xN.bnumtofloat(xN.e())
	local LogTen = bnum[2] + math.log10(bnum[1])
	LogTen = LogTen / math.log10(b)	
	return xN.errorcorrection(xN.new(LogTen, 0))
end
function xN.fact(bnum)
	local TwoPin = xN.mul(xN.pi(), xN.two())
	local res2 = xN.div({1/12, 0}, bnum)
	local res3 =  xN.div({1/360, 0}, xN.pow(bnum, {3, 0}))
	TwoPin = xN.mul(TwoPin, bnum)
	TwoPin = xN.sqrt(TwoPin)
	res2 = xN.sub(res2, res3)
	res2 = xN.pow(xN.e(), res2)
	res3 = xN.div(bnum, xN.e())
	res3 = xN.pow(res3, bnum)
	res3 = xN.mul(res3, TwoPin)
	local Final = xN.mul(res2, res3)
	if Final[2] <= -1 and Final[1] > 9.99 then
		Final[2] = -1
	elseif Final[2] <= -1 then
		Final[2] = 0
	end
	return Final
end
function xN.gamma(bnum)
	return xN.fact(xN.sub(bnum, {1, 0}))
end
function xN.doublefactOdd(bnum)
	if xN.eq(bnum, {1, 0}) then
		return {1, 0}
	end
	return xN.mul(xN.sqrt(xN.div(xN.pow({2, 0}, xN.add(bnum, {1, 0})), xN.pi())), xN.fact(xN.div(bnum, xN.two())))
end
function xN.doublefactEven(bnum)
	local Num =  xN.fact(xN.div(bnum, {2, 0}))
	return xN.mul(xN.pow{2, xN.div(bnum, {2, 0})}, Num)
end
function xN.rand(bnum1, bnum2)

	local Ye = xN.convert(math.random())

	local bnum3 = xN.mul(Ye, xN.sub(bnum1, bnum2))
	bnum3 = xN.add(bnum3, bnum2)
	return bnum3
end
function xN.fmod(bnum1, bnum2)
	bnum1 = xN.errorcorrection(bnum1)
	bnum2 = xN.errorcorrection(bnum2)
	local MultiplyBy = bnum2
	local origexp = bnum2[1]
	local origtet = bnum2[2]
	bnum2[2] = bnum1[2]
	if bnum1[2] > bnum2[2] then
		bnum2[2] = bnum1[2] - 1
	end
	local M = 0
	repeat
		local VT = xN.div(bnum1, bnum2)
		VT = xN.floor(VT)
		VT = xN.mul(VT, bnum2)
		bnum1 = xN.sub(bnum1, VT)
		bnum2[2] = bnum2[2] - 1
	until xN.le(bnum1, {origexp, origtet})
	if xN.eq(bnum1, xN.abs(bnum1)) then
	else
		return xN.fmod(xN.abs(bnum1), {origexp, origtet})
	end
	return bnum1
end
function xN.expoRand(bnum1, bnum2)
	local Ye = xN.convert(xN.rand(xN.log10(bnum1),xN.log10(bnum2)))
	local bnum3 = xN.pow(xN.ten(), Ye)
	return bnum3
end
function xN.abs(bnum1)
	return {math.abs(bnum1[1]), bnum1[2]}
end
function xN.between(bnum1, bnum2, bnum3)
	return xN.leeq(bnum1, bnum3) and xN.meeq(bnum1, bnum2)

end
function xN.floor(bnum1)
	if xN.meeq(bnum1, {1, 16}) or  xN.leeq(bnum1, {-1, 16}) then
		return bnum1
	end
	return xN.convert(math.floor(xN.bnumtofloat(bnum1)))
end
function xN.ceil(bnum2)
	if xN.meeq(bnum2, {1, 16}) or  xN.leeq(bnum2, {-1, 16}) then
		return bnum2
	end
	return xN.convert(math.ceil(xN.bnumtofloat(bnum2)))
end
function xN.round(bnum2)
	return xN.floor(xN.add(bnum2, {5, -1}))
end
function xN.shift(bnum2, digits)

	return {math.floor(bnum2[1] * 10^digits) / 10^digits, bnum2[2]}
end
function xN.engineer(bnum)
	if math.fmod(bnum[2], 3) ~= 0 then
		local ree = bnum[2]
		bnum[2] = bnum[2] - math.fmod(bnum[2], 3)
		bnum[1] = bnum[1] * 10 ^ math.fmod(ree, 3)
		return xN.bnumtostr(xN.shift(bnum,4))
	end
	return xN.bnumtostr(xN.shift(bnum,4))
end

return xN]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX10F2144EF39D468080CB3247646F0B67">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Number</string>
						<string name="ScriptGuid">{22DB4AF2-0F8B-484A-89E3-0660AF47CE17}</string>
						<ProtectedString name="Source"><![CDATA[local suffixes = {
	"", "k", "m", "b", "t", "qd", "qn", "sx", "sp",
	"oc", "No", "De", "UDe", "DDe", "TDe", "QdDe", "QnDe", "SxDe",
	"SpDe", "OcDe", "NoDe", "Vt", "UVt", "DVt", "TVt", "QdVt", "QnVt",
	"SxVt", "SpVt", "OcVt", "NoVt", "Tg", "UTg", "DTg", "TTg", "QdTg",
	"QnTg", "SxTg", "SpTg", "OcTg", "NoTg", "qg", "Uqg", "Dqg", "Tqg",
	"Qdqg", "Qnqg", "Sxqg", "Spqg", "Ocqg", "Noqg", "Qg", "UQg", "DQg",
	"TQg", "QdQg", "QnQg", "SxQg", "SpQg", "OcQg", "NoQg", "sg", "Usg",
	"Dsg", "Tsg", "Qdsg", "Qnsg", "Sxsg", "Spsg", "Ocsg", "Nosg", "Sg",
	"USg", "DSg", "TSg", "QdSg", "QnSg", "SxSg", "SpSg", "OcSg", "NoSg",
	"Og", "UOg", "DOg", "TOg", "QdOg", "QnOg", "SxOg", "SpOg", "OcOg",
	"NoOg", "Ng", "UNg", "DNg", "QdNg", "QnNg", "SxNg", "SpNg", "OcNg",
	"NoNg", "Ce", "UCe", "DCe"
}

local Number = {}

function Number.floor(value: number, prec)
	prec = prec or 2
	local exp = 10^prec
	value = (value*exp-value*exp%1)/exp
	return value
end


function Number.correct(value, format)
	local trail
	if value % 1 == 0 then
		trail = string.format('%.0'..format, value)
	elseif value % 0.1 == 0 then
		trail = string.format('%.1'..format, value)
	elseif value % 0.01 == 0 then
		trail = string.format('%.2'..format, value)
	end
	return trail
end

function Number.me(value1: number, value2)
	if value1 > value2 then
		return true
	end
	return false
end

function Number.le(value1: number, value2)
	if value1 < value2 then
		return true
	end
	return false
end

function Number.eq(value1: number, value2)
	if value1 == value2 then
		return true
	end
	return false
end

function Number.meeq(value1, value2)
	local me = Number.me(value1, value2)
	local eq = Number.eq(value1, value2)
	if me or eq then
		return true
	end
	return false
end

function Number.leeq(value1, value2)
	local eq = Number.eq(value1, value2)
	local le = Number.le(value1, value2)
	if le or eq then
		return true
	end
	return false
end

function Number.div(value1: number, value2)
	local result = value1/value2
	return result
end

function Number.add(value1: number, value2)
	local result = value1+value2
	return result
end

function Number.sub(value1: number, value2)
	local result = value1-value2
	if Number.le(result, 0) then
		return 0
	end
	return result
end

function Number.mul(value1: number, value2)
	local mul = value1*value2
	return mul
end

function Number.pow(value1: number, value2)
	return math.pow(value1, value2)
end

function Number.fmod(value1: number, value2)
	local fmod = math.fmod(value1, value2)
	return fmod
end

function Number.log(value1: number, value2)
	local log = math.log(value1, value2)
	return log
end

function round(value, precision, result)
	return math.floor(value*precision+result)/precision
end

function Number.round(value, precision)
	if not precision then precision = 2 end
	local mul = 10^(precision)
	return round(value, mul, 0.5)
end

function Number.short(value, setting: 'Yes' | 'No')
	if setting == 'Yes' then
		local mod = math.log10(value)
		mod = math.floor(mod)
		local index = math.floor(mod/3)+1
		index = math.clamp(index, 1, #suffixes)
		value = value/10^(3*(index-1))
		value = Number.floor(value, 2)
		return value..suffixes[index]
	else
		local index = 1
		while Number.meeq(value, 1000) and Number.le(index, #suffixes) do
			value = Number.div(value, 1000)
			index = Number.add(index, 1)
		end
		value = Number.floor(value, 2)
		return string.format('%.2f', value)..suffixes[index]
	end
end

function createPrecentage(value1: number, value2, precision)
	if not precision then precision = 0 end
	local prec = Number.div(value1, value2)
	local form = string.format('%.2f%%', prec)
	if prec then
		form = string.format(`%.{precision}f%%`, prec)
	end
	return form
end

function Number.Percentage(value1: number, value2, precision)
	if Number.meeq(value1, value2) then
		return '100%'
	end
	return createPrecentage(value1, value2, precision)
end

function Number.correctVal(val1: number)
	if Number.eq(val1, 1/0) then val1 = 0 end
	if Number.eq(val1, 0/0) then val1 = 0 end
	if Number.eq(val1, -1,0) then val1 = 0 end
	return val1
end

function Number.toScience(val1: number, setting: 'Yes' | 'No')
	if setting == 'Yes' then
		local exp = math.floor(math.abs(math.log10(val1)))
		exp = Number.correctVal(exp)
		local man = val1/10^exp
		man = Number.floor(man, 2)
		return man..'e'..exp
	else
		local exp = math.floor(math.abs(math.log10(val1)))
		exp = Number.correctVal(exp)
		local man = val1/10^exp
		return string.format('%.2f', man)..'e'..exp
	end
end

function createCommaTrail(value)
	if Number.meeq(value, 1000) then
		if Number.meeq(value, 10^12) then
			return '999,999,999,999+'
		end
		local format = tostring(Number.round(value, 2))
		local sep = ','
		for i = #format-3, 1, -3 do
			format = format:sub(1, i)..sep..format:sub(i+1)
		end
		return format
	else
		return tostring(Number.round(value))
	end
end

function Number.Comma(value)
	return createCommaTrail(value)
end

function Number.CommaToShort(value, setting)
	if Number.meeq(value, 10^12) then
		return Number.short(value, setting)
	end
	return Number.Comma(value)
end

function Number.CommaToE(value)
	if Number.meeq(value, 10^12) then
		return Number.toScience(value)
	end
	return Number.Comma(value)
end

function Number.ShortToE(value, setting)
	if Number.meeq(value, 1e30) then
		return Number.toScience(value, setting)
	end
	return Number.short(value, setting)
end

return Number]]></ProtectedString>
						<int64 name="SourceAssetId">16710610002</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX3CE14C0C52DC459C9F8301C6C8DD47FF">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Zone</string>
						<string name="ScriptGuid">{C6F787E0-9671-4A26-8AFC-DBB269819D6E}</string>
						<ProtectedString name="Source"><![CDATA[-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local localPlayer = runService:IsClient() and players.LocalPlayer
local replicatedStorage = game:GetService("ReplicatedStorage")
local httpService = game:GetService("HttpService")
local Enum_ = require(script.Enum)
local enum = Enum_.enums
local Janitor = require(script.Janitor)
local Signal = require(script.Signal)
local ZonePlusReference = require(script.ZonePlusReference)
local referenceObject = ZonePlusReference.getObject()
local zoneControllerModule = script.ZoneController
local trackerModule = zoneControllerModule.Tracker
local collectiveWorldModelModule = zoneControllerModule.CollectiveWorldModel
local ZoneController = require(zoneControllerModule)
local referenceLocation = (game:GetService("RunService"):IsClient() and "Client") or "Server"
local referencePresent = referenceObject and referenceObject:FindFirstChild(referenceLocation)
if referencePresent then
	return require(referenceObject.Value)
end

local Zone = {}
Zone.__index = Zone
if not referencePresent then
	ZonePlusReference.addToReplicatedStorage()
end
Zone.enum = enum



-- CONSTRUCTORS
function Zone.new(container)
	local self = {}
	setmetatable(self, Zone)
	
	-- Validate container
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	local containerType = typeof(container)
	if not(containerType == "table" or containerType == "Instance") then
		error(INVALID_TYPE_WARNING)
	end

	-- Configurable
	self.accuracy = enum.Accuracy.High
	self.autoUpdate = true
	self.respectUpdateQueue = true
	--self.maxPartsAddition = 20
	--self.ignoreRecommendedMaxParts = false

	-- Variable
	local janitor = Janitor.new()
	self.janitor = janitor
	self._updateConnections = janitor:add(Janitor.new(), "destroy")
	self.container = container
	self.zoneParts = {}
	self.overlapParams = {}
	self.region = nil
	self.volume = nil
	self.boundMin = nil
	self.boundMax = nil
	self.recommendedMaxParts = nil
	self.zoneId = httpService:GenerateGUID()
	self.activeTriggers = {}
	self.occupants = {}
	self.trackingTouchedTriggers = {}
	self.enterDetection = enum.Detection.Centre
	self.exitDetection = enum.Detection.Centre
	self._currentEnterDetection = nil -- This will update automatically internally
	self._currentExitDetection = nil -- This will also update automatically internally
	self.totalPartVolume = 0
	self.allZonePartsAreBlocks = true
	self.trackedItems = {}
	self.settingsGroupName = nil
	self.worldModel = workspace
	self.onItemDetails = {}
	self.itemsToUntrack = {}

	-- This updates _currentEnterDetection and _currentExitDetection right away to prevent nil comparisons
	ZoneController.updateDetection(self)

	-- Signals
	self.updated = janitor:add(Signal.new(), "destroy")
	local triggerTypes = {
		"player",
		"part",
		"localPlayer",
		"item"
	}
	local triggerEvents = {
		"entered",
		"exited",
	}
	for _, triggerType in pairs(triggerTypes) do
		local activeConnections = 0
		local previousActiveConnections = 0
		for i, triggerEvent in pairs(triggerEvents) do
			-- this enables us to determine when a developer connects to an event
			-- so that we can act accoridngly (i.e. begin or end a checker loop)
			local signal = janitor:add(Signal.new(true), "destroy")
			local triggerEventUpper = triggerEvent:sub(1,1):upper()..triggerEvent:sub(2)
			local signalName = triggerType..triggerEventUpper
			self[signalName] = signal
			signal.connectionsChanged:Connect(function(increment)
				if triggerType == "localPlayer" and not localPlayer and increment == 1 then
					error(("Can only connect to 'localPlayer%s' on the client!"):format(triggerEventUpper))
				end
				previousActiveConnections = activeConnections
				activeConnections += increment
				if previousActiveConnections == 0 and activeConnections > 0 then
					-- At least 1 connection active, begin loop
					ZoneController._registerConnection(self, triggerType, triggerEventUpper)
				elseif previousActiveConnections > 0 and activeConnections == 0 then
					-- All connections have disconnected, end loop
					ZoneController._deregisterConnection(self, triggerType)
				end
			end)
		end
	end

	-- Setup touched receiver functions where applicable
	Zone.touchedConnectionActions = {}
	for _, triggerType in pairs(triggerTypes) do
		local methodName = ("_%sTouchedZone"):format(triggerType)
		local correspondingMethod = self[methodName]
		if correspondingMethod then
			self.trackingTouchedTriggers[triggerType] = {}
			Zone.touchedConnectionActions[triggerType] = function(touchedItem)
				correspondingMethod(self, touchedItem)
			end
		end
	end

	-- This constructs the zones boundaries, region, etc
	self:_update()

	-- Register/deregister zone
	ZoneController._registerZone(self)
	janitor:add(function()
		ZoneController._deregisterZone(self)
	end, true)
	
	return self
end

function Zone.fromRegion(cframe, size)
	local MAX_PART_SIZE = 2024
	local container = Instance.new("Model")
	local function createCube(cubeCFrame, cubeSize)
		if cubeSize.X > MAX_PART_SIZE or cubeSize.Y > MAX_PART_SIZE or cubeSize.Z > MAX_PART_SIZE then
			local quarterSize = cubeSize * 0.25
			local halfSize = cubeSize * 0.5
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(-quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, -quarterSize.Y, quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, -quarterSize.Z), halfSize)
			createCube(cubeCFrame * CFrame.new(quarterSize.X, quarterSize.Y, quarterSize.Z), halfSize)
		else
			local part = Instance.new("Part")
			part.CFrame = cubeCFrame
			part.Size = cubeSize
			part.Anchored = true
			part.Parent = container
		end
	end
	createCube(cframe, size)
	local zone = Zone.new(container)
	zone:relocate()
	return zone
end



-- PRIVATE METHODS
function Zone:_calculateRegion(tableOfParts, dontRound)
	local bounds = {["Min"] = {}, ["Max"] = {}}
	for boundType, details in pairs(bounds) do
		details.Values = {}
		function details.parseCheck(v, currentValue)
			if boundType == "Min" then
				return (v <= currentValue)
			elseif boundType == "Max" then
				return (v >= currentValue)
			end
		end
		function details:parse(valuesToParse)
			for i,v in pairs(valuesToParse) do
				local currentValue = self.Values[i] or v
				if self.parseCheck(v, currentValue) then
					self.Values[i] = v
				end
			end
		end
	end
	for _, part in pairs(tableOfParts) do
		local sizeHalf = part.Size * 0.5
		local corners = {
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(-sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, -sizeHalf.Y, sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, -sizeHalf.Z),
			part.CFrame * CFrame.new(sizeHalf.X, sizeHalf.Y, sizeHalf.Z),
		}
		for _, cornerCFrame in pairs(corners) do
			local x, y, z = cornerCFrame:GetComponents()
			local values = {x, y, z}
			bounds.Min:parse(values)
			bounds.Max:parse(values)
		end
	end
	local minBound = {}
	local maxBound = {}
	-- Rounding a regions coordinates to multiples of 4 ensures the region optimises the region
	-- by ensuring it aligns on the voxel grid
	local function roundToFour(to_round)
		local ROUND_TO = 4
		local divided = (to_round+ROUND_TO/2) / ROUND_TO
		local rounded = ROUND_TO * math.floor(divided)
		return rounded
	end
	for boundName, boundDetail in pairs(bounds) do
		for _, v in pairs(boundDetail.Values) do
			local newTable = (boundName == "Min" and minBound) or maxBound
			local newV = v
			if not dontRound then
				local roundOffset = (boundName == "Min" and -2) or 2
				newV = roundToFour(v+roundOffset) -- +-2 to ensures the zones region is not rounded down/up
			end
			table.insert(newTable, newV)
		end
	end
	local boundMin = Vector3.new(unpack(minBound))
	local boundMax = Vector3.new(unpack(maxBound))
	local region = Region3.new(boundMin, boundMax)
	return region, boundMin, boundMax
end

function Zone:_displayBounds()
	if not self.displayBoundParts then
		self.displayBoundParts = true
		local boundParts = {BoundMin = self.boundMin, BoundMax = self.boundMax}
		for boundName, boundCFrame in pairs(boundParts) do
			local part = Instance.new("Part")
			part.Anchored = true
			part.CanCollide = false
			part.Transparency = 0.5
			part.Size = Vector3.new(1,1,1)
			part.Color = Color3.fromRGB(255,0,0)
			part.CFrame = CFrame.new(boundCFrame)
			part.Name = boundName
			part.Parent = workspace
			self.janitor:add(part, "Destroy")
		end
	end
end

function Zone:_update()
	local container = self.container
	local zoneParts = {}
	local updateQueue = 0
	self._updateConnections:clean()

	local containerType = typeof(container)
	local holders = {}
	local INVALID_TYPE_WARNING = "The zone container must be a model, folder, basepart or table!"
	if containerType == "table" then
		for _, part in pairs(container) do
			if part:IsA("BasePart") then
				table.insert(zoneParts, part)
			end
		end
	elseif containerType == "Instance" then
		if container:IsA("BasePart") then
			table.insert(zoneParts, container)
		else
			table.insert(holders, container)
			for _, part in pairs(container:GetDescendants()) do
				if part:IsA("BasePart") then
					table.insert(zoneParts, part)
				else
					table.insert(holders, part)
				end
			end
		end
	end
	self.zoneParts = zoneParts
	self.overlapParams = {}
	
	local allZonePartsAreBlocksNew = true
	for _, zonePart in pairs(zoneParts) do
		local success, shapeName = pcall(function() return zonePart.Shape.Name end)
		if shapeName ~= "Block" then
			allZonePartsAreBlocksNew = false
		end
	end
	self.allZonePartsAreBlocks = allZonePartsAreBlocksNew
	
	local zonePartsWhitelist = OverlapParams.new()
	zonePartsWhitelist.FilterType = Enum.RaycastFilterType.Whitelist
	zonePartsWhitelist.MaxParts = #zoneParts
	zonePartsWhitelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsWhitelist = zonePartsWhitelist

	local zonePartsIgnorelist = OverlapParams.new()
	zonePartsIgnorelist.FilterType = Enum.RaycastFilterType.Blacklist
	zonePartsIgnorelist.FilterDescendantsInstances = zoneParts
	self.overlapParams.zonePartsIgnorelist = zonePartsIgnorelist
	
	-- this will call update on the zone when the container parts size or position changes, and when a
	-- child is removed or added from a holder (anything which isn't a basepart)
	local function update()
		if self.autoUpdate then
			local executeTime = os.clock()
			if self.respectUpdateQueue then
				updateQueue += 1
				executeTime += 0.1
			end
			local updateConnection
			updateConnection = runService.Heartbeat:Connect(function()
				if os.clock() >= executeTime then
					updateConnection:Disconnect()
					if self.respectUpdateQueue then
						updateQueue -= 1
					end
					if updateQueue == 0 and self.zoneId then
						self:_update()
					end
				end
			end)
		end
	end
	local partProperties = {"Size", "Position"}
	local function verifyDefaultCollision(instance)
		if instance.CollisionGroupId ~= 0 then
			error("Zone parts must belong to the 'Default' (0) CollisionGroup! Consider using zone:relocate() if you wish to move zones outside of workspace to prevent them interacting with other parts.")
		end
	end
	for _, part in pairs(zoneParts) do
		for _, prop in pairs(partProperties) do
			self._updateConnections:add(part:GetPropertyChangedSignal(prop):Connect(update), "Disconnect")
		end
		verifyDefaultCollision(part)
		self._updateConnections:add(part:GetPropertyChangedSignal("CollisionGroupId"):Connect(function()
			verifyDefaultCollision(part)
		end), "Disconnect")
	end
	local containerEvents = {"ChildAdded", "ChildRemoved"}
	for _, holder in pairs(holders) do
		for _, event in pairs(containerEvents) do
			self._updateConnections:add(self.container[event]:Connect(function(child)
				if child:IsA("BasePart") then
					update()
				end
			end), "Disconnect")
		end
	end
	
	local region, boundMin, boundMax = self:_calculateRegion(zoneParts)
	local exactRegion, _, _ = self:_calculateRegion(zoneParts, true)
	self.region = region
	self.exactRegion = exactRegion
	self.boundMin = boundMin
	self.boundMax = boundMax
	local rSize = region.Size
	self.volume = rSize.X*rSize.Y*rSize.Z
	
	-- Update: I was going to use this for the old part detection until the CanTouch property was released
	-- everything below is now irrelevant however I'll keep just in case I use again for future
	-------------------------------------------------------------------------------------------------
	-- When a zones region is determined, we also check for parts already existing within the zone
	-- these parts are likely never to move or interact with the zone, so we set the number of these
	-- to the baseline MaxParts value. 'recommendMaxParts' is then determined through the sum of this
	-- and maxPartsAddition. This ultimately optimises region checks as they can be generated with
	-- minimal MaxParts (i.e. recommendedMaxParts can be used instead of math.huge every time)
	--[[
	local result = self.worldModel:FindPartsInRegion3(region, nil, math.huge)
	local maxPartsBaseline = #result
	self.recommendedMaxParts = maxPartsBaseline + self.maxPartsAddition
	--]]
	
	self:_updateTouchedConnections()
	
	self.updated:Fire()
end

function Zone:_updateOccupants(trackerName, newOccupants)
	local previousOccupants = self.occupants[trackerName]
	if not previousOccupants then
		previousOccupants = {}
		self.occupants[trackerName] = previousOccupants
	end
	local signalsToFire = {}
	for occupant, prevItem in pairs(previousOccupants) do
		local newItem = newOccupants[occupant]
		if newItem == nil or newItem ~= prevItem then
			previousOccupants[occupant] = nil
			if not signalsToFire.exited then
				signalsToFire.exited = {}
			end
			table.insert(signalsToFire.exited, occupant)
		end
	end
	for occupant, _ in pairs(newOccupants) do
		if previousOccupants[occupant] == nil then
			local isAPlayer = occupant:IsA("Player")
			previousOccupants[occupant] = (isAPlayer and occupant.Character) or true
			if not signalsToFire.entered then
				signalsToFire.entered = {}
			end
			table.insert(signalsToFire.entered, occupant)
		end
	end 
	return signalsToFire
end

function Zone:_formTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:clean()
	else
		touchedJanitor = self.janitor:add(Janitor.new(), "destroy")
		self[touchedJanitorName] = touchedJanitor
	end
	self:_updateTouchedConnection(triggerType)
end

function Zone:_updateTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if not touchedJanitor then return end
	for _, basePart in pairs(self.zoneParts) do
		touchedJanitor:add(basePart.Touched:Connect(self.touchedConnectionActions[triggerType], self), "Disconnect")
	end
end

function Zone:_updateTouchedConnections()
	for triggerType, _ in pairs(self.touchedConnectionActions) do
		local touchedJanitorName = "_touchedJanitor"..triggerType
		local touchedJanitor = self[touchedJanitorName]
		if touchedJanitor then
			touchedJanitor:cleanup()
			self:_updateTouchedConnection(triggerType)
		end
	end
end

function Zone:_disconnectTouchedConnection(triggerType)
	local touchedJanitorName = "_touchedJanitor"..triggerType
	local touchedJanitor = self[touchedJanitorName]
	if touchedJanitor then
		touchedJanitor:cleanup()
		self[touchedJanitorName] = nil
	end
end

local function round(number, decimalPlaces)
	return math.round(number * 10^decimalPlaces) * 10^-decimalPlaces
end
function Zone:_partTouchedZone(part)
	local trackingDict = self.trackingTouchedTriggers["part"]
	if trackingDict[part] then return end
	local nextCheck = 0
	local verifiedEntrance = false
	local enterPosition = part.Position
	local enterTime = os.clock()
	local partJanitor = self.janitor:add(Janitor.new(), "destroy")
	trackingDict[part] = partJanitor
	local instanceClassesToIgnore = {Seat = true, VehicleSeat = true}
	local instanceNamesToIgnore = {HumanoidRootPart = true}
	if not (instanceClassesToIgnore[part.ClassName] or not instanceNamesToIgnore[part.Name])  then
		part.CanTouch = false
	end
	--
	local partVolume = round((part.Size.X * part.Size.Y * part.Size.Z), 5)
	self.totalPartVolume += partVolume
	--
	partJanitor:add(heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			----
			local cooldown = enum.Accuracy.getProperty(self.accuracy)
			nextCheck = clockTime + cooldown
			----

			-- We initially perform a singular point check as this is vastly more lightweight than a large part check
			-- If the former returns false, perform a whole part check in case the part is on the outer bounds.
			local withinZone = self:findPoint(part.CFrame)
			if not withinZone then
				withinZone = self:findPart(part)
			end
			if not verifiedEntrance then
				if withinZone then
					verifiedEntrance = true
					self.partEntered:Fire(part)
				elseif (part.Position - enterPosition).Magnitude > 1.5 and clockTime - enterTime >= cooldown then
					-- Even after the part has exited the zone, we track it for a brief period of time based upon the criteria
					-- in the line above to ensure the .touched behaviours are not abused
					partJanitor:cleanup()
				end
			elseif not withinZone then
				verifiedEntrance = false
				enterPosition = part.Position
				enterTime = os.clock()
				self.partExited:Fire(part)
			end
		end
	end), "Disconnect")
	partJanitor:add(function()
		trackingDict[part] = nil
		part.CanTouch = true
		self.totalPartVolume = round((self.totalPartVolume - partVolume), 5)
	end, true)
end

local partShapeActions = {
	["Ball"] = function(part)
		return "GetPartBoundsInRadius", {part.Position, part.Size.X}
	end,
	["Block"] = function(part)
		return "GetPartBoundsInBox", {part.CFrame, part.Size}
	end,
	["Other"] = function(part)
		return "GetPartsInPart", {part}
	end,
}
function Zone:_getRegionConstructor(part, overlapParams)
	local success, shapeName = pcall(function() return part.Shape.Name end)
	local methodName, args
	if success and self.allZonePartsAreBlocks then
		local action = partShapeActions[shapeName]
		if action then
			methodName, args = action(part)
		end
	end
	if not methodName then
		methodName, args = partShapeActions.Other(part)
	end
	if overlapParams then
		table.insert(args, overlapParams)
	end
	return methodName, args
end



-- PUBLIC METHODS
function Zone:findLocalPlayer()
	if not localPlayer then
		error("Can only call 'findLocalPlayer' on the client!")
	end
	return self:findPlayer(localPlayer)
end

function Zone:_find(trackerName, item)
	ZoneController.updateDetection(self)
	local tracker = ZoneController.trackers[trackerName]
	local touchingZones = ZoneController.getTouchingZones(item, false, self._currentEnterDetection, tracker)
	for _, zone in pairs(touchingZones) do
		if zone == self then
			return true
		end
	end
	return false
end

function Zone:findPlayer(player)
	local character = player.Character
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return false
	end
	return self:_find("player", player.Character)
end

function Zone:findItem(item)
	return self:_find("item", item)
end

function Zone:findPart(part)
	local methodName, args = self:_getRegionConstructor(part, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(part, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:getCheckerPart()
	local checkerPart = self.checkerPart
	if not checkerPart then
		checkerPart = self.janitor:add(Instance.new("Part"), "Destroy")
		checkerPart.Size = Vector3.new(0.1, 0.1, 0.1)
		checkerPart.Name = "ZonePlusCheckerPart"
		checkerPart.Anchored = true
		checkerPart.Transparency = 1
		checkerPart.CanCollide = false
		self.checkerPart = checkerPart
	end
	local checkerParent = self.worldModel
	if checkerParent == workspace then
		checkerParent = ZoneController.getWorkspaceContainer()
	end
	if checkerPart.Parent ~= checkerParent then
		checkerPart.Parent = checkerParent
	end
	return checkerPart
end

function Zone:findPoint(positionOrCFrame)
	local cframe = positionOrCFrame
	if typeof(positionOrCFrame) == "Vector3" then
		cframe = CFrame.new(positionOrCFrame)
	end
	local checkerPart = self:getCheckerPart()
	checkerPart.CFrame = cframe
	--checkerPart.Parent = self.worldModel
	local methodName, args = self:_getRegionConstructor(checkerPart, self.overlapParams.zonePartsWhitelist)
	local touchingZoneParts = self.worldModel[methodName](self.worldModel, unpack(args))
	--local touchingZoneParts = self.worldModel:GetPartsInPart(self.checkerPart, self.overlapParams.zonePartsWhitelist)
	if #touchingZoneParts > 0 then
		return true, touchingZoneParts
	end
	return false
end

function Zone:_getAll(trackerName)
	ZoneController.updateDetection(self)
	local itemsArray = {}
	local zonesAndOccupants = ZoneController._getZonesAndItems(trackerName, {self = true}, self.volume, false, self._currentEnterDetection)
	local occupantsDict = zonesAndOccupants[self]
	if occupantsDict then
		for item, _ in pairs(occupantsDict) do
			table.insert(itemsArray, item)
		end
	end
	return itemsArray
end

function Zone:getPlayers()
	return self:_getAll("player")
end

function Zone:getItems()
	return self:_getAll("item")
end

function Zone:getParts()
	-- This is designed for infrequent 'one off' use
	-- If you plan on checking for parts within a zone frequently, it's recommended you
	-- use the .partEntered and .partExited events instead.
	local partsArray = {}
	if self.activeTriggers["part"] then
		local trackingDict = self.trackingTouchedTriggers["part"]
		for part, _ in pairs(trackingDict) do
			table.insert(partsArray, part)
		end
		return partsArray
	end
	local partsInRegion = self.worldModel:GetPartBoundsInBox(self.region.CFrame, self.region.Size, self.overlapParams.zonePartsIgnorelist)
	for _, part in pairs(partsInRegion) do
		if self:findPart(part) then
			table.insert(partsArray, part)
		end
	end
	return partsArray
end

function Zone:getRandomPoint()
	local region = self.exactRegion
	local size = region.Size
	local cframe = region.CFrame
	local random = Random.new()
	local randomCFrame
	local success, touchingZoneParts
	local pointIsWithinZone
	repeat
		randomCFrame = cframe * CFrame.new(random:NextNumber(-size.X/2,size.X/2), random:NextNumber(-size.Y/2,size.Y/2), random:NextNumber(-size.Z/2,size.Z/2))
		success, touchingZoneParts = self:findPoint(randomCFrame)
		if success then
			pointIsWithinZone = true
		end
	until pointIsWithinZone
	local randomVector = randomCFrame.Position
	return randomVector, touchingZoneParts
end

function Zone:setAccuracy(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Accuracy[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Accuracy.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.accuracy = enumId
end

function Zone:setDetection(enumIdOrName)
	local enumId = tonumber(enumIdOrName)
	if not enumId then
		enumId = enum.Detection[enumIdOrName]
		if not enumId then
			error(("'%s' is an invalid enumName!"):format(enumIdOrName))
		end
	else
		local enumName = enum.Detection.getName(enumId)
		if not enumName then
			error(("%s is an invalid enumId!"):format(enumId))
		end
	end
	self.enterDetection = enumId
	self.exitDetection = enumId
end

function Zone:trackItem(instance)
	local isBasePart = instance:IsA("BasePart")
	local isCharacter = false
	if not isBasePart then
		isCharacter = instance:FindFirstChildOfClass("Humanoid") and instance:FindFirstChild("HumanoidRootPart")
	end

	assert(isBasePart or isCharacter, "Only BaseParts or Characters/NPCs can be tracked!")

	if self.trackedItems[instance] then
		return
	end
	if self.itemsToUntrack[instance] then
		self.itemsToUntrack[instance] = nil
	end

	local itemJanitor = self.janitor:add(Janitor.new(), "destroy")
	local itemDetail = {
		janitor = itemJanitor,
		item = instance,
		isBasePart = isBasePart,
		isCharacter = isCharacter,
	}
	self.trackedItems[instance] = itemDetail

	itemJanitor:add(instance.AncestryChanged:Connect(function()
		if not instance:IsDescendantOf(game) then
			self:untrackItem(instance)
		end
	end), "Disconnect")

	local Tracker = require(trackerModule)
	Tracker.itemAdded:Fire(itemDetail)
end

function Zone:untrackItem(instance)
	local itemDetail = self.trackedItems[instance]
	if itemDetail then
		itemDetail.janitor:destroy()
	end
	self.trackedItems[instance] = nil

	local Tracker = require(trackerModule)
	Tracker.itemRemoved:Fire(itemDetail)
end

function Zone:bindToGroup(settingsGroupName)
	self:unbindFromGroup()
	local group = ZoneController.getGroup(settingsGroupName) or ZoneController.setGroup(settingsGroupName)
	group._memberZones[self.zoneId] = self
	self.settingsGroupName = settingsGroupName
end

function Zone:unbindFromGroup()
	if self.settingsGroupName then
		local group = ZoneController.getGroup(self.settingsGroupName)
		if group then
			group._memberZones[self.zoneId] = nil
		end
		self.settingsGroupName = nil
	end
end

function Zone:relocate()
	if self.hasRelocated then
		return
	end

	local CollectiveWorldModel = require(collectiveWorldModelModule)
	local worldModel = CollectiveWorldModel.setupWorldModel(self)
	self.worldModel = worldModel
	self.hasRelocated = true
	
	local relocationContainer = self.container
	if typeof(relocationContainer) == "table" then
		relocationContainer = Instance.new("Folder")
		for _, zonePart in pairs(self.zoneParts) do
			zonePart.Parent = relocationContainer
		end
	end
	self.relocationContainer = self.janitor:add(relocationContainer, "Destroy", "RelocationContainer")
	relocationContainer.Parent = worldModel
end

function Zone:_onItemCallback(eventName, desiredValue, instance, callbackFunction)
	local detail = self.onItemDetails[instance]
	if not detail then
		detail = {}
		self.onItemDetails[instance] = detail
	end
	if #detail == 0 then
		self.itemsToUntrack[instance] = true
	end
	table.insert(detail, instance)
	self:trackItem(instance)

	local function triggerCallback()
		callbackFunction()
		if self.itemsToUntrack[instance] then
			self.itemsToUntrack[instance] = nil
			self:untrackItem(instance)
		end
	end

	local inZoneAlready = self:findItem(instance)
	if inZoneAlready == desiredValue then
		triggerCallback()
	else
		local connection
		connection = self[eventName]:Connect(function(item)
			if connection and item == instance then
				connection:Disconnect()
				connection = nil
				triggerCallback()
			end
		end)
		--[[
		if typeof(expireAfterSeconds) == "number" then
			task.delay(expireAfterSeconds, function()
				if connection ~= nil then
					print("EXPIRE!")
					connection:Disconnect()
					connection = nil
					triggerCallback()
				end
			end)
		end
		--]]
	end
end

function Zone:onItemEnter(...)
	self:_onItemCallback("itemEntered", true, ...)
end

function Zone:onItemExit(...)
	self:_onItemCallback("itemExited", false, ...)
end

function Zone:destroy()
	self:unbindFromGroup()
	self.janitor:destroy()
end
Zone.Destroy = Zone.destroy

return Zone]]></ProtectedString>
						<int64 name="SourceAssetId">6245329519</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX99A95C70085E4F25955A3FEF9B6AD8F6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Enum</string>
							<string name="ScriptGuid">{8C9DBC9F-45FB-4745-B7DC-4D6ABA5C95CA}</string>
							<ProtectedString name="Source"><![CDATA[-- Custom enum implementation that provides an effective way to compare, send
-- and store values. Instead of returning a userdata value, enum items return
-- their corresponding itemValue (an integer) when indexed. Enum items can
-- also associate a 'property', specified as the third element, which can be
-- retrieved by doing ``enum.getProperty(ITEM_NAME_OR_VALUE)``
-- This ultimately means groups of data can be easily categorised, efficiently
-- transmitted over networks and saved without throwing errors.
-- Ben Horton (ForeverHD)



-- LOCAL
local Enum = {}
local enums = {}
Enum.enums = enums



-- METHODS
function Enum.createEnum(enumName, details)
	assert(typeof(enumName) == "string", "bad argument #1 - enums must be created using a string name!")
	assert(typeof(details) == "table", "bad argument #2 - enums must be created using a table!")
	assert(not enums[enumName], ("enum '%s' already exists!"):format(enumName))
	
	local enum = {}
	local usedNames = {}
	local usedValues = {}
	local usedProperties = {}
	local enumMetaFunctions = {
		getName = function(valueOrProperty)
			valueOrProperty = tostring(valueOrProperty)
			local index = usedValues[valueOrProperty]
			if not index then
				index = usedProperties[valueOrProperty]
			end
			if index then
				return details[index][1]
			end
		end,
		getValue = function(nameOrProperty)
			nameOrProperty = tostring(nameOrProperty)
			local index = usedNames[nameOrProperty]
			if not index then
				index = usedProperties[nameOrProperty]
			end
			if index then
				return details[index][2]
			end
		end,
		getProperty = function(nameOrValue)
			nameOrValue = tostring(nameOrValue)
			local index = usedNames[nameOrValue]
			if not index then
				index = usedValues[nameOrValue]
			end
			if index then
				return details[index][3]
			end
		end
	}
	for i, detail in pairs(details) do
		assert(typeof(detail) == "table", ("bad argument #2.%s - details must only be comprised of tables!"):format(i))
		local name = detail[1]
		assert(typeof(name) == "string", ("bad argument #2.%s.1 - detail name must be a string!"):format(i))
		assert(typeof(not usedNames[name]), ("bad argument #2.%s.1 - the detail name '%s' already exists!"):format(i, name))
		assert(typeof(not enumMetaFunctions[name]), ("bad argument #2.%s.1 - that name is reserved."):format(i, name))
		usedNames[tostring(name)] = i
		local value = detail[2]
		local valueString = tostring(value)
		--assert(typeof(value) == "number" and math.ceil(value)/value == 1, ("bad argument #2.%s.2 - detail value must be an integer!"):format(i))
		assert(typeof(not usedValues[valueString]), ("bad argument #2.%s.2 - the detail value '%s' already exists!"):format(i, valueString))
		usedValues[valueString] = i
		local property = detail[3]
		if property then
			assert(typeof(not usedProperties[property]), ("bad argument #2.%s.3 - the detail property '%s' already exists!"):format(i, tostring(property)))
			usedProperties[tostring(property)] = i
		end
		enum[name] = value
		setmetatable(enum, {
			__index = function(_, index)
				return(enumMetaFunctions[index])
			end
		})
	end
	
	enums[enumName] = enum
	return enum
end

function Enum.getEnums()
	return enums
end



-- SETUP ENUMS
local createEnum = Enum.createEnum
for _, childModule in pairs(script:GetChildren()) do
	if childModule:IsA("ModuleScript") then
		local enumDetail = require(childModule)
		createEnum(childModule.Name, enumDetail)
	end
end

--[[
-- Example enum
createEnum("Color", {
	{"White", 1, Color3.fromRGB(255, 255, 255)},
	{"Black", 2, Color3.fromRGB(0, 0, 0)},
})
--]]



return Enum
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXCDB08FBDFC1B4A90ABAC84C1F2700719">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Accuracy</string>
								<string name="ScriptGuid">{D25185CE-3140-4BAE-B707-D0BA59FB7650}</string>
								<ProtectedString name="Source"><![CDATA[-- enumName, enumValue, additionalProperty
-- in this case, additionalProperty is the delay between each check
return {
	{"Low", 	1,	1.0},
	{"Medium",	2,	0.5},
	{"High",	3,	0.1},
	{"Precise",	4,	0.0},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB5F5A5C0A3574278846880BD5E76E139">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Detection</string>
								<string name="ScriptGuid">{A9EEA085-7E00-4BEF-A60A-4C5F78BB2B42}</string>
								<ProtectedString name="Source"><![CDATA[-- Important note: Precision checks currently only for 'players' and the 'localplayer', not 'parts'.

-- enumName, enumValue, additionalProperty
return {
	{"WholeBody", 1}, -- Multiple checks will be casted over an entire players character
	{"Centre", 2}, -- A singular check will be performed on the players HumanoidRootPart
	--{"Automatic", 3}, -- REMOVED DUE TO UNECESSARY COMPLEXITY. ZonePlus will dynamically switch between 'WholeBody' and 'Centre' depending upon the number of players in a server (this typically only occurs for servers with 100+ players when volume checks begin to exceed 0.5% in script performance).
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXF9F5D540FD05437AB4CAC4F40DD5B05A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Janitor</string>
							<string name="ScriptGuid">{4782B169-E45A-476C-A490-B7E59C7D519A}</string>
							<ProtectedString name="Source"><![CDATA[-- Janitor
-- Original by Validark
-- Modifications by pobammer
-- roblox-ts support by OverHash and Validark
-- LinkToInstance fixed by Elttob.

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat

local IndicesReference = newproxy(true)
getmetatable(IndicesReference).__tostring = function()
	return "IndicesReference"
end

local LinkToInstanceIndex = newproxy(true)
getmetatable(LinkToInstanceIndex).__tostring = function()
	return "LinkToInstanceIndex"
end

local METHOD_NOT_FOUND_ERROR = "Object %s doesn't have method %s, are you sure you want to add it? Traceback: %s"
--local NOT_A_PROMISE = "Invalid argument #1 to 'Janitor:AddPromise' (Promise expected, got %s (%s))"

local Janitor = {
	ClassName = "Janitor";
	__index = {
		CurrentlyCleaning = true;
		[IndicesReference] = nil;
	};
}

local TypeDefaults = {
	["function"] = true;
	RBXScriptConnection = "Disconnect";
}

--[[**
	Instantiates a new Janitor object.
	@returns [t:Janitor]
**--]]
function Janitor.new()
	return setmetatable({
		CurrentlyCleaning = false;
		[IndicesReference] = nil;
	}, Janitor)
end

--[[**
	Determines if the passed object is a Janitor.
	@param [t:any] Object The object you are checking.
	@returns [t:boolean] Whether or not the object is a Janitor.
**--]]
function Janitor.Is(Object)
	return type(Object) == "table" and getmetatable(Object) == Janitor
end

Janitor.is = Janitor.Is

--[[**
	Adds an `Object` to Janitor for later cleanup, where `MethodName` is the key of the method within `Object` which should be called at cleanup time. If the `MethodName` is `true` the `Object` itself will be called instead. If passed an index it will occupy a namespace which can be `Remove()`d or overwritten. Returns the `Object`.
	@param [t:any] Object The object you want to clean up.
	@param [t:string|true?] MethodName The name of the method that will be used to clean up. If not passed, it will first check if the object's type exists in TypeDefaults, and if that doesn't exist, it assumes `Destroy`.
	@param [t:any?] Index The index that can be used to clean up the object manually.
	@returns [t:any] The object that was passed.
**--]]
function Janitor.__index:Add(Object, MethodName, Index)
	if Index == nil then
		Index = newproxy(false)
	end

	if Index then
		self:Remove(Index)

		local This = self[IndicesReference]
		if not This then
			This = {}
			self[IndicesReference] = This
		end

		This[Index] = Object
	end
	--[[
	if Promise.is(Object) then
		local Id = newproxy(false)
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	end--]]

	MethodName = MethodName or TypeDefaults[typeof(Object)] or "Destroy"
	if type(Object) ~= "function" and not Object[MethodName] then
		warn(string.format(METHOD_NOT_FOUND_ERROR, tostring(Object), tostring(MethodName), debug.traceback(nil, 2)))
	end

	self[Object] = MethodName
	return Object, Index
end

Janitor.__index.Give = Janitor.__index.Add

-- My version of Promise has PascalCase, but I converted it to use lowerCamelCase for this release since obviously that's important to do.

--[[**
	Adds a promise to the janitor. If the janitor is cleaned up and the promise is not completed, the promise will be cancelled.
	@param [t:Promise] PromiseObject The promise you want to add to the janitor.
	@returns [t:Promise]
**--]]
--[[
function Janitor.__index:AddPromise(PromiseObject)
	if not Promise.is(PromiseObject) then
		error(string.format(NOT_A_PROMISE, typeof(PromiseObject), tostring(PromiseObject)))
	end

	if PromiseObject:getStatus() == Promise.Status.Started then
		local Id = newproxy(false)
		local NewPromise = self:Add(Promise.resolve(PromiseObject), "cancel", Id)
		NewPromise:finallyCall(self.Remove, self, Id)
		return NewPromise, Id
	else
		return PromiseObject
	end
end
--]]

--Janitor.__index.GivePromise = Janitor.__index.AddPromise

-- This will assume whether or not the object is a Promise or a regular object.
function Janitor.__index:AddObject(Object)
	local Id = newproxy(false)
	--[[
	if Promise.is(Object) then
		if Object:getStatus() == Promise.Status.Started then
			local NewPromise = self:Add(Promise.resolve(Object), "cancel", Id)
			NewPromise:finallyCall(self.Remove, self, Id)
			return NewPromise, Id
		else
			return Object
		end
	else
		return self:Add(Object, false, Id), Id
	end---]]
	return self:Add(Object, false, Id), Id
end

Janitor.__index.GiveObject = Janitor.__index.AddObject

--[[**
	Cleans up whatever `Object` was set to this namespace by the 3rd parameter of `:Add()`.
	@param [t:any] Index The index you want to remove.
	@returns [t:Janitor] The same janitor, for chaining reasons.
**--]]
function Janitor.__index:Remove(Index)
	local This = self[IndicesReference]

	if This then
		local Object = This[Index]

		if Object then
			local MethodName = self[Object]

			if MethodName then
				if MethodName == true then
					Object()
				else
					local ObjectMethod = Object[MethodName]
					if ObjectMethod then
						ObjectMethod(Object)
					end
				end

				self[Object] = nil
			end

			This[Index] = nil
		end
	end

	return self
end

--[[**
	Gets whatever object is stored with the given index, if it exists. This was added since Maid allows getting the job using `__index`.
	@param [t:any] Index The index that the object is stored under.
	@returns [t:any?] This will return the object if it is found, but it won't return anything if it doesn't exist.
**--]]
function Janitor.__index:Get(Index)
	local This = self[IndicesReference]
	if This then
		return This[Index]
	end
end

--[[**
	Calls each Object's `MethodName` (or calls the Object if `MethodName == true`) and removes them from the Janitor. Also clears the namespace. This function is also called when you call a Janitor Object (so it can be used as a destructor callback).
	@returns [t:void]
**--]]
function Janitor.__index:Cleanup()
	if not self.CurrentlyCleaning then
		self.CurrentlyCleaning = nil
		for Object, MethodName in next, self do
			if Object == IndicesReference then
				continue
			end

			-- Weird decision to rawset directly to the janitor in Agent. This should protect against it though.
			local TypeOf = type(Object)
			if TypeOf == "string" or TypeOf == "number" then
				self[Object] = nil
				continue
			end

			if MethodName == true then
				Object()
			else
				local ObjectMethod = Object[MethodName]
				if ObjectMethod then
					ObjectMethod(Object)
				end
			end

			self[Object] = nil
		end

		local This = self[IndicesReference]
		if This then
			for Index in next, This do
				This[Index] = nil
			end

			self[IndicesReference] = {}
		end

		self.CurrentlyCleaning = false
	end
end

Janitor.__index.Clean = Janitor.__index.Cleanup

--[[**
	Calls `:Cleanup()` and renders the Janitor unusable.
	@returns [t:void]
**--]]
function Janitor.__index:Destroy()
	self:Cleanup()
	--table.clear(self)
	--setmetatable(self, nil)
end

Janitor.__call = Janitor.__index.Cleanup

--- Makes the Janitor clean up when the instance is destroyed
-- @param Instance Instance The Instance the Janitor will wait for to be Destroyed
-- @returns Disconnectable table to stop Janitor from being cleaned up upon Instance Destroy (automatically cleaned up by Janitor, btw)
-- @author Corecii
local Disconnect = {Connected = true}
Disconnect.__index = Disconnect
function Disconnect:Disconnect()
	if self.Connected then
		self.Connected = false
		self.Connection:Disconnect()
	end
end

function Disconnect:__tostring()
	return "Disconnect<" .. tostring(self.Connected) .. ">"
end

--[[**
	"Links" this Janitor to an Instance, such that the Janitor will `Cleanup` when the Instance is `Destroyed()` and garbage collected. A Janitor may only be linked to one instance at a time, unless `AllowMultiple` is true. When called with a truthy `AllowMultiple` parameter, the Janitor will "link" the Instance without overwriting any previous links, and will also not be overwritable. When called with a falsy `AllowMultiple` parameter, the Janitor will overwrite the previous link which was also called with a falsy `AllowMultiple` parameter, if applicable.
	@param [t:Instance] Object The instance you want to link the Janitor to.
	@param [t:boolean?] AllowMultiple Whether or not to allow multiple links on the same Janitor.
	@returns [t:RbxScriptConnection] A pseudo RBXScriptConnection that can be disconnected.
**--]]
function Janitor.__index:LinkToInstance(Object, AllowMultiple)
	local Connection
	local IndexToUse = AllowMultiple and newproxy(false) or LinkToInstanceIndex
	local IsNilParented = Object.Parent == nil
	local ManualDisconnect = setmetatable({}, Disconnect)

	local function ChangedFunction(_DoNotUse, NewParent)
		if ManualDisconnect.Connected then
			_DoNotUse = nil
			IsNilParented = NewParent == nil

			if IsNilParented then
				coroutine.wrap(function()
					Heartbeat:Wait()
					if not ManualDisconnect.Connected then
						return
					elseif not Connection.Connected then
						self:Cleanup()
					else
						while IsNilParented and Connection.Connected and ManualDisconnect.Connected do
							Heartbeat:Wait()
						end

						if ManualDisconnect.Connected and IsNilParented then
							self:Cleanup()
						end
					end
				end)()
			end
		end
	end

	Connection = Object.AncestryChanged:Connect(ChangedFunction)
	ManualDisconnect.Connection = Connection

	if IsNilParented then
		ChangedFunction(nil, Object.Parent)
	end

	Object = nil
	return self:Add(ManualDisconnect, "Disconnect", IndexToUse)
end

--[[**
	Links several instances to a janitor, which is then returned.
	@param [t:...Instance] ... All the instances you want linked.
	@returns [t:Janitor] A janitor that can be used to manually disconnect all LinkToInstances.
**--]]
function Janitor.__index:LinkToInstances(...)
	local ManualCleanup = Janitor.new()
	for _, Object in ipairs({...}) do
		ManualCleanup:Add(self:LinkToInstance(Object, true), "Disconnect")
	end

	return ManualCleanup
end

for FunctionName, Function in next, Janitor.__index do
	local NewFunctionName = string.sub(string.lower(FunctionName), 1, 1) .. string.sub(FunctionName, 2)
	Janitor.__index[NewFunctionName] = Function
end

return Janitor]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA92576BCBE1C4AD88CB4E89111863429">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">OldSignal</string>
							<string name="ScriptGuid">{3347D8D6-F709-4DD2-B47B-31C83A3E8B30}</string>
							<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local heartbeat = RunService.Heartbeat
local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"
Signal.totalConnections = 0



-- CONSTRUCTOR
function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({}, Signal)
	
	if createConnectionsChangedSignal then
		self.connectionsChanged = Signal.new()
	end

	self.connections = {}
	self.totalConnections = 0
	self.waiting = {}
	self.totalWaiting = 0

	return self
end



-- METHODS
function Signal:Fire(...)
	for _, connection in pairs(self.connections) do
		--connection.Handler(...)
		task.spawn(connection.Handler, ...)
	end
	if self.totalWaiting > 0 then
		local packedArgs = table.pack(...)
		for waitingId, _ in pairs(self.waiting) do
			self.waiting[waitingId] = packedArgs
		end
	end
end
Signal.fire = Signal.Fire

function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end
	
	local signal = self
	local connectionId = HttpService:GenerateGUID(false)
	local connection = {}
	connection.Connected = true
	connection.ConnectionId = connectionId
	connection.Handler = handler
	self.connections[connectionId] = connection

	function connection:Disconnect()
		signal.connections[connectionId] = nil
		connection.Connected = false
		signal.totalConnections -= 1
		if signal.connectionsChanged then
			signal.connectionsChanged:Fire(-1)
		end
	end
	connection.Destroy = connection.Disconnect
	connection.destroy = connection.Disconnect
	connection.disconnect = connection.Disconnect
	self.totalConnections += 1
	if self.connectionsChanged then
		self.connectionsChanged:Fire(1)
	end

	return connection
end
Signal.connect = Signal.Connect

function Signal:Wait()
	local waitingId = HttpService:GenerateGUID(false)
	self.waiting[waitingId] = true
	self.totalWaiting += 1
	repeat heartbeat:Wait() until self.waiting[waitingId] ~= true
	self.totalWaiting -= 1
	local args = self.waiting[waitingId]
	self.waiting[waitingId] = nil
	return unpack(args)
end
Signal.wait = Signal.Wait

function Signal:Destroy()
	if self.bindableEvent then
		self.bindableEvent:Destroy()
		self.bindableEvent = nil
	end
	if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
	end
	self.totalConnections = 0
	for connectionId, connection in pairs(self.connections) do
		self.connections[connectionId] = nil
	end
end
Signal.destroy = Signal.Destroy
Signal.Disconnect = Signal.Destroy
Signal.disconnect = Signal.Destroy



return Signal]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB7A56A42211945A5A5931A52FB217D14">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Signal</string>
							<string name="ScriptGuid">{1B2132CA-EF0E-416F-9184-77900F08D4C7}</string>
							<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- API:                                                                       --
--   local Signal = require(THIS MODULE)                                      --
--   local sig = Signal.new()                                                 --
--   local connection = sig:Connect(function(arg1, arg2, ...) ... end)        --
--   sig:Fire(arg1, arg2, ...)                                                --
--   connection:Disconnect()                                                  --
--   sig:DisconnectAll()                                                      --
--   local arg1, arg2, ... = sig:Wait()                                       --
--                                                                            --
-- Licence:                                                                   --
--   Licenced under the MIT licence.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--------------------------------------------------------------------------------

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be 
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection.new(signal, fn)
	return setmetatable({
		_connected = true,
		_signal = signal,
		_fn = fn,
		_next = false,
	}, Connection)
end

function Connection:Disconnect()
	assert(self._connected, "Can't disconnect a connection twice.", 2)
	self._connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
    local signal = self._signal
	if signal._handlerListHead == self then
		signal._handlerListHead = self._next
	else
		local prev = signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end

    if signal.connectionsChanged then
		signal.totalConnections -= 1
        signal.connectionsChanged:Fire(-1)
    end
end

-- Make Connection strict
setmetatable(Connection, {
	__index = function(tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(tb, key, value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end
})

-- Signal class
local Signal = {}
Signal.__index = Signal

function Signal.new(createConnectionsChangedSignal)
	local self = setmetatable({
		_handlerListHead = false,	
	}, Signal)
    if createConnectionsChangedSignal then
        self.totalConnections = 0
		self.connectionsChanged = Signal.new()
	end
    return self
end

function Signal:Connect(fn)
	local connection = Connection.new(self, fn)
	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	if self.connectionsChanged then
        self.totalConnections += 1
		self.connectionsChanged:Fire(1)
	end
	return connection
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
function Signal:DisconnectAll()
	self._handlerListHead = false

    if self.connectionsChanged then
		self.connectionsChanged:Fire(-self.totalConnections)
		self.connectionsChanged:Destroy()
		self.connectionsChanged = nil
		self.totalConnections = 0
	end
end
Signal.Destroy = Signal.DisconnectAll
Signal.destroy = Signal.DisconnectAll

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item._connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

-- Implement Signal:Wait() in terms of a temporary connection using
-- a Signal:Connect() which disconnects itself.
function Signal:Wait()
	local waitingCoroutine = coroutine.running()
	local cn;
	cn = self:Connect(function(...)
		cn:Disconnect()
		task.spawn(waitingCoroutine, ...)
	end)
	return coroutine.yield()
end


return Signal]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC4C258BEEDCD41B59A9EC8E551B97862">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VERSION</string>
							<string name="ScriptGuid">{3FBF82F2-2DD9-429B-8DE1-D4448B36B80E}</string>
							<ProtectedString name="Source">-- v3.2.0</ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA02BB806D2B34080A5E28618313C1975">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ZoneController</string>
							<string name="ScriptGuid">{FE193D61-4993-4972-9153-75617A310DD8}</string>
							<ProtectedString name="Source"><![CDATA[-- CONFIG
local WHOLE_BODY_DETECTION_LIMIT = 729000 -- This is roughly the volume where Region3 checks begin to exceed 0.5% in Script Performance



-- LOCAL
local Janitor = require(script.Parent.Janitor)
local Enum_ = require(script.Parent.Enum)
local Signal = require(script.Parent.Signal)
local Tracker = require(script.Tracker)
local CollectiveWorldModel = require(script.CollectiveWorldModel)
local enum = Enum_.enums
local players = game:GetService("Players")
local activeZones = {}
local activeZonesTotalVolume = 0
local activeTriggers = {}
local registeredZones = {}
local activeParts = {}
local activePartToZone = {}
local allParts = {}
local allPartToZone = {}
local activeConnections = 0
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local heartbeatConnections = {}
local localPlayer = runService:IsClient() and players.LocalPlayer



-- PUBLIC
local ZoneController = {}
local trackers = {}
trackers.player = Tracker.new("player")
trackers.item = Tracker.new("item")
ZoneController.trackers = trackers



-- LOCAL FUNCTIONS
local function dictLength(dictionary)
	local count = 0
	for _, _ in pairs(dictionary) do
		count += 1
	end
	return count
end

local function fillOccupants(zonesAndOccupantsTable, zone, occupant)
	local occupantsDict = zonesAndOccupantsTable[zone]
	if not occupantsDict then
		occupantsDict = {}
		zonesAndOccupantsTable[zone] = occupantsDict
	end
	local prevCharacter = occupant:IsA("Player") and occupant.Character
	occupantsDict[occupant] = (prevCharacter or true)
end

local heartbeatActions = {
	["player"] = function(recommendedDetection)
		return ZoneController._getZonesAndItems("player", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
	["localPlayer"] = function(recommendedDetection)
		local zonesAndOccupants = {}
		local character = localPlayer.Character
		if not character then
			return zonesAndOccupants
		end
		local touchingZones = ZoneController.getTouchingZones(character, true, recommendedDetection, trackers.player)
		for _, zone in pairs(touchingZones) do
			if zone.activeTriggers["localPlayer"] then
				fillOccupants(zonesAndOccupants, zone, localPlayer)
			end
		end
		return zonesAndOccupants
	end,
	["item"] = function(recommendedDetection)
		return ZoneController._getZonesAndItems("item", activeZones, activeZonesTotalVolume, true, recommendedDetection)
	end,
}



-- PRIVATE FUNCTIONS
function ZoneController._registerZone(zone)
   	registeredZones[zone] = true
	local registeredJanitor = zone.janitor:add(Janitor.new(), "destroy")
	zone._registeredJanitor = registeredJanitor
	registeredJanitor:add(zone.updated:Connect(function()
		ZoneController._updateZoneDetails()
	end), "Disconnect")
   ZoneController._updateZoneDetails()
end

function ZoneController._deregisterZone(zone)
	registeredZones[zone] = nil
	zone._registeredJanitor:destroy()
	zone._registeredJanitor = nil
	ZoneController._updateZoneDetails()
end

function ZoneController._registerConnection(registeredZone, registeredTriggerType)
	local originalItems = dictLength(registeredZone.activeTriggers)
	activeConnections += 1
	if originalItems == 0 then
		activeZones[registeredZone] = true
		ZoneController._updateZoneDetails()
	end
	local currentTriggerCount = activeTriggers[registeredTriggerType]
	activeTriggers[registeredTriggerType] = (currentTriggerCount and currentTriggerCount+1) or 1
	registeredZone.activeTriggers[registeredTriggerType] = true
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_formTouchedConnection(registeredTriggerType)
	end
	if heartbeatActions[registeredTriggerType] then
		ZoneController._formHeartbeat(registeredTriggerType)
	end
end

-- This decides what to do if detection is 'Automatic'
-- This is placed in ZoneController instead of the Zone object due to the ZoneControllers all-knowing group-minded logic
function ZoneController.updateDetection(zone)
	local detectionTypes = {
		["enterDetection"] = "_currentEnterDetection",
		["exitDetection"] = "_currentExitDetection",
	}
	for detectionType, currentDetectionName in pairs(detectionTypes) do
		local detection = zone[detectionType]
		local combinedTotalVolume = Tracker.getCombinedTotalVolumes()
		if detection == enum.Detection.Automatic then
			if combinedTotalVolume > WHOLE_BODY_DETECTION_LIMIT then
				detection = enum.Detection.Centre
			else
				detection = enum.Detection.WholeBody
			end
		end
		zone[currentDetectionName] = detection
	end
end

function ZoneController._formHeartbeat(registeredTriggerType)
	local heartbeatConnection = heartbeatConnections[registeredTriggerType]
	if heartbeatConnection then return end
	-- This will only ever connect once per triggerType per server
	-- This means instead of initiating a loop per-zone we can handle everything within
	-- a singular connection. This is particularly beneficial for player/item-orinetated
	-- checking, where a check only needs to be cast once per interval, as apposed
	-- to every zone per interval
	-- I utilise heartbeat with os.clock() to provide precision (where needed) and flexibility
	local nextCheck = 0
	heartbeatConnection = heartbeat:Connect(function()
		local clockTime = os.clock()
		if clockTime >= nextCheck then
			local lowestAccuracy
			local lowestDetection
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					if lowestAccuracy == nil or zAccuracy < lowestAccuracy then
						lowestAccuracy = zAccuracy
					end
					ZoneController.updateDetection(zone)
					local zDetection = zone._currentEnterDetection
					if lowestDetection == nil or zDetection < lowestDetection then
						lowestDetection = zDetection
					end
				end
			end
			local highestAccuracy = lowestAccuracy
			local zonesAndOccupants = heartbeatActions[registeredTriggerType](lowestDetection)

			-- If a zone belongs to a settingsGroup with 'onlyEnterOnceExitedAll = true' , and the occupant already exists in a member group, then
			-- ignore all incoming occupants for the other zones (preventing the enteredSignal from being fired until the occupant has left
			-- all other zones within the same settingGroup)
			local occupantsToBlock = {}
			local zonesToPotentiallyIgnore = {}
			for zone, newOccupants in pairs(zonesAndOccupants) do
				local settingsGroup = (zone.settingsGroupName and ZoneController.getGroup(zone.settingsGroupName))
				if settingsGroup and settingsGroup.onlyEnterOnceExitedAll == true then
					--local currentOccupants = zone.occupants[registeredTriggerType]
					--if currentOccupants then
						for newOccupant, _ in pairs(newOccupants) do
							--if currentOccupants[newOccupant] then
								local groupDetail = occupantsToBlock[zone.settingsGroupName]
								if not groupDetail then
									groupDetail = {}
									occupantsToBlock[zone.settingsGroupName] = groupDetail
								end
								groupDetail[newOccupant] = zone
							--end
						end
						zonesToPotentiallyIgnore[zone] = newOccupants
					--end
				end
			end
			for zone, newOccupants in pairs(zonesToPotentiallyIgnore) do
				local groupDetail = occupantsToBlock[zone.settingsGroupName]
				if groupDetail then
					for newOccupant, _ in pairs(newOccupants) do
						local occupantToKeepZone = groupDetail[newOccupant]
						if occupantToKeepZone and occupantToKeepZone ~= zone then
							newOccupants[newOccupant] = nil
						end
					end
				end
			end

			-- This deduces what signals should be fired
			local collectiveSignalsToFire = {{}, {}}
			for zone, _ in pairs(activeZones) do
				if zone.activeTriggers[registeredTriggerType] then
					local zAccuracy = zone.accuracy
					local occupantsDict = zonesAndOccupants[zone] or {}
					local occupantsPresent = false
					for k,v in pairs(occupantsDict) do
						occupantsPresent = true
						break
					end
					if occupantsPresent and zAccuracy > highestAccuracy then
						highestAccuracy = zAccuracy
					end
					local signalsToFire = zone:_updateOccupants(registeredTriggerType, occupantsDict)
					collectiveSignalsToFire[1][zone] = signalsToFire.exited
					collectiveSignalsToFire[2][zone] = signalsToFire.entered
				end
			end

			-- This ensures all exited signals and called before entered signals
			local indexToSignalType = {"Exited", "Entered"}
			for index, zoneAndOccupants in pairs(collectiveSignalsToFire) do
				local signalType = indexToSignalType[index]
				local signalName = registeredTriggerType..signalType
				for zone, occupants in pairs(zoneAndOccupants) do
					local signal = zone[signalName]
					if signal then
						for _, occupant in pairs(occupants) do
							signal:Fire(occupant)
						end
					end
				end
			end

			local cooldown = enum.Accuracy.getProperty(highestAccuracy)
			nextCheck = clockTime + cooldown
		end
	end)
	heartbeatConnections[registeredTriggerType] = heartbeatConnection
end

function ZoneController._deregisterConnection(registeredZone, registeredTriggerType)
	activeConnections -= 1
	if activeTriggers[registeredTriggerType] == 1 then
		activeTriggers[registeredTriggerType] = nil
		local heartbeatConnection = heartbeatConnections[registeredTriggerType]
		if heartbeatConnection then
			heartbeatConnections[registeredTriggerType] = nil
			heartbeatConnection:Disconnect()
		end
	else
		activeTriggers[registeredTriggerType] -= 1
	end
	registeredZone.activeTriggers[registeredTriggerType] = nil
	if dictLength(registeredZone.activeTriggers) == 0 then
		activeZones[registeredZone] = nil
		ZoneController._updateZoneDetails()
	end
	if registeredZone.touchedConnectionActions[registeredTriggerType] then
		registeredZone:_disconnectTouchedConnection(registeredTriggerType)
	end
end

function ZoneController._updateZoneDetails()
	activeParts = {}
	activePartToZone = {}
	allParts = {}
	allPartToZone = {}
	activeZonesTotalVolume = 0
	for zone, _ in pairs(registeredZones) do
		local isActive = activeZones[zone]
		if isActive then
			activeZonesTotalVolume += zone.volume
		end
		for _, zonePart in pairs(zone.zoneParts) do
			if isActive then
				table.insert(activeParts, zonePart)
				activePartToZone[zonePart] = zone
			end
			table.insert(allParts, zonePart)
			allPartToZone[zonePart] = zone
		end
	end
end

function ZoneController._getZonesAndItems(trackerName, zonesDictToCheck, zoneCustomVolume, onlyActiveZones, recommendedDetection)
	local totalZoneVolume = zoneCustomVolume
	if not totalZoneVolume then
		for zone, _ in pairs(zonesDictToCheck) do
			totalZoneVolume += zone.volume
		end
	end
	local zonesAndOccupants = {}
	local tracker = trackers[trackerName]
	if tracker.totalVolume < totalZoneVolume then
		-- If the volume of all *characters/items* within the server is *less than* the total
		-- volume of all active zones (i.e. zones which listen for .playerEntered)
		-- then it's more efficient cast checks within each character and
		-- then determine the zones they belong to
		for _, item in pairs(tracker.items) do
			local touchingZones = ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
			for _, zone in pairs(touchingZones) do
				if not onlyActiveZones or zone.activeTriggers[trackerName] then
					local finalItem = item
					if trackerName == "player" then
						finalItem = players:GetPlayerFromCharacter(item)
					end
					if finalItem then
						fillOccupants(zonesAndOccupants, zone, finalItem)
					end
				end
			end
		end
	else
		-- If the volume of all *active zones* within the server is *less than* the total
		-- volume of all characters/items, then it's more efficient to perform the
		-- checks directly within each zone to determine players inside
		for zone, _ in pairs(zonesDictToCheck) do
			if not onlyActiveZones or zone.activeTriggers[trackerName] then
				local result = CollectiveWorldModel:GetPartBoundsInBox(zone.region.CFrame, zone.region.Size, tracker.whitelistParams)
				local finalItemsDict = {}
				for _, itemOrChild in pairs(result) do
					local correspondingItem = tracker.partToItem[itemOrChild]
					if not finalItemsDict[correspondingItem] then
						finalItemsDict[correspondingItem] = true
					end
				end
				for item, _ in pairs(finalItemsDict) do
					if trackerName == "player" then
						local player = players:GetPlayerFromCharacter(item)
						if zone:findPlayer(player) then
							fillOccupants(zonesAndOccupants, zone, player)
						end
					elseif zone:findItem(item) then
						fillOccupants(zonesAndOccupants, zone, item)
					end
				end
			end
		end
	end
	return zonesAndOccupants
end



-- PUBLIC FUNCTIONS
function ZoneController.getZones()
	local registeredZonesArray = {}
	for zone, _ in pairs(registeredZones) do
		table.insert(registeredZonesArray, zone)
	end
	return registeredZonesArray
end

--[[
-- the player touched events which utilise active zones at the moment may change to the new CanTouch method for parts in the future
-- hence im disabling this as it may be depreciated quite soon
function ZoneController.getActiveZones()
	local zonesArray = {}
	for zone, _ in pairs(activeZones) do
		table.insert(zonesArray, zone)
	end
	return zonesArray
end
--]]

function ZoneController.getTouchingZones(item, onlyActiveZones, recommendedDetection, tracker)
	local exitDetection, finalDetection
	if tracker then
		exitDetection = tracker.exitDetections[item]
		tracker.exitDetections[item] = nil
	end
	finalDetection = exitDetection or recommendedDetection

	local itemSize, itemCFrame
	local itemIsBasePart = item:IsA("BasePart")
	local itemIsCharacter = not itemIsBasePart
	local bodyPartsToCheck = {}
	if itemIsBasePart then
		itemSize, itemCFrame = item.Size, item.CFrame
		table.insert(bodyPartsToCheck, item)
	elseif finalDetection == enum.Detection.WholeBody then
		itemSize, itemCFrame = Tracker.getCharacterSize(item)
		bodyPartsToCheck = item:GetChildren()
	else
		local hrp = item:FindFirstChild("HumanoidRootPart")
		if hrp then
			itemSize, itemCFrame = hrp.Size, hrp.CFrame
			table.insert(bodyPartsToCheck, hrp)
		end
	end
	if not itemSize or not itemCFrame then return {} end

	--[[
	local part = Instance.new("Part")
	part.Size = itemSize
	part.CFrame = itemCFrame
	part.Anchored = true
	part.CanCollide = false
	part.Color = Color3.fromRGB(255, 0, 0)
	part.Transparency = 0.4
	part.Parent = workspace
	game:GetService("Debris"):AddItem(part, 2)
	--]]
	local partsTable = (onlyActiveZones and activeParts) or allParts
	local partToZoneDict = (onlyActiveZones and activePartToZone) or allPartToZone

	local boundParams = OverlapParams.new()
	boundParams.FilterType = Enum.RaycastFilterType.Whitelist
	boundParams.MaxParts = #partsTable
	boundParams.FilterDescendantsInstances = partsTable

	-- This retrieves the bounds (the rough shape) of all parts touching the item/character
	-- If the corresponding zone is made up of *entirely* blocks then the bound will
	-- be the actual shape of the part.
	local touchingPartsDictionary = {}
	local zonesDict = {}
	local boundParts = CollectiveWorldModel:GetPartBoundsInBox(itemCFrame, itemSize, boundParams)
	local boundPartsThatRequirePreciseChecks = {}
	for _, boundPart in pairs(boundParts) do
		local correspondingZone = partToZoneDict[boundPart]
		if correspondingZone and correspondingZone.allZonePartsAreBlocks then
			zonesDict[correspondingZone] = true
			touchingPartsDictionary[boundPart] = correspondingZone
		else
			table.insert(boundPartsThatRequirePreciseChecks, boundPart)
		end
	end

	-- If the bound parts belong to a zone that isn't entirely made up of blocks, then
	-- we peform additional checks using GetPartsInPart which enables shape
	-- geometries to be precisely determined for non-block baseparts.
	local totalRemainingBoundParts = #boundPartsThatRequirePreciseChecks
	local precisePartsCount = 0
	if totalRemainingBoundParts > 0 then
		
		local preciseParams = OverlapParams.new()
		preciseParams.FilterType = Enum.RaycastFilterType.Whitelist
		preciseParams.MaxParts = totalRemainingBoundParts
		preciseParams.FilterDescendantsInstances = boundPartsThatRequirePreciseChecks

		local character = item
		for _, bodyPart in pairs(bodyPartsToCheck) do
			local endCheck = false
			if not bodyPart:IsA("BasePart") or (itemIsCharacter and Tracker.bodyPartsToIgnore[bodyPart.Name]) then
				continue
			end
			local preciseParts = CollectiveWorldModel:GetPartsInPart(bodyPart, preciseParams)
			for _, precisePart in pairs(preciseParts) do
				if not touchingPartsDictionary[precisePart] then
					local correspondingZone = partToZoneDict[precisePart]
					if correspondingZone then
						zonesDict[correspondingZone] = true
						touchingPartsDictionary[precisePart] = correspondingZone
						precisePartsCount += 1
					end
					if precisePartsCount == totalRemainingBoundParts then
						endCheck = true
						break
					end
				end
			end
			if endCheck then
				break
			end
		end
	end
	
	local touchingZonesArray = {}
	local newExitDetection
	for zone, _ in pairs(zonesDict) do
		if newExitDetection == nil or zone._currentExitDetection < newExitDetection then
			newExitDetection = zone._currentExitDetection
		end
		table.insert(touchingZonesArray, zone)
	end
	if newExitDetection and tracker then
		tracker.exitDetections[item] = newExitDetection
	end
	return touchingZonesArray, touchingPartsDictionary
end

local settingsGroups = {}
function ZoneController.setGroup(settingsGroupName, properties)
	local group = settingsGroups[settingsGroupName]
	if not group then
		group = {}
		settingsGroups[settingsGroupName] = group
	end
	

	-- PUBLIC PROPERTIES --
	group.onlyEnterOnceExitedAll = true
	
	-- PRIVATE PROPERTIES --
	group._name = settingsGroupName
	group._memberZones = {}


	if typeof(properties) == "table" then
		for k, v in pairs(properties) do
			group[k] = v
		end
	end
	return group
end

function ZoneController.getGroup(settingsGroupName)
	return settingsGroups[settingsGroupName]
end

local workspaceContainer
local workspaceContainerName = string.format("ZonePlus%sContainer", (runService:IsClient() and "Client") or "Server")
function ZoneController.getWorkspaceContainer()
	local container = workspaceContainer or workspace:FindFirstChild(workspaceContainerName)
	if not container then
		container = Instance.new("Folder")
		container.Name = workspaceContainerName
		container.Parent = workspace
		workspaceContainer = container
	end
	return container
end



return ZoneController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX954FCF683AE148D4840DFFFBF3014186">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CollectiveWorldModel</string>
								<string name="ScriptGuid">{26F741BF-0346-4186-9A55-F546D44DA750}</string>
								<ProtectedString name="Source"><![CDATA[local CollectiveWorldModel = {}
local worldModel
local runService = game:GetService("RunService")



-- FUNCTIONS
function CollectiveWorldModel.setupWorldModel(zone)
	if worldModel then
		return worldModel
	end
	local location = (runService:IsClient() and "ReplicatedStorage") or "ServerStorage"
	worldModel = Instance.new("WorldModel")
	worldModel.Name = "ZonePlusWorldModel"
	worldModel.Parent = game:GetService(location)
	return worldModel
end



-- METHODS
function CollectiveWorldModel:_getCombinedResults(methodName, ...)
	local results = workspace[methodName](workspace, ...)
	if worldModel then
		local additionalResults = worldModel[methodName](worldModel, ...)
		for _, result in pairs(additionalResults) do
			table.insert(results, result)
		end
	end
	return results
end

function CollectiveWorldModel:GetPartBoundsInBox(cframe, size, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInBox", cframe, size, overlapParams)
end

function CollectiveWorldModel:GetPartBoundsInRadius(position, radius, overlapParams)
	return self:_getCombinedResults("GetPartBoundsInRadius", position, radius, overlapParams)
end

function CollectiveWorldModel:GetPartsInPart(part, overlapParams)
	return self:_getCombinedResults("GetPartsInPart", part, overlapParams)
end



return CollectiveWorldModel]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6BFAB662F6724F888168DF2117CFB550">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Tracker</string>
								<string name="ScriptGuid">{B89347DC-0723-4119-B15E-059314E1FCA3}</string>
								<ProtectedString name="Source"><![CDATA[-- This enables data on volumes, HumanoidRootParts, etc to be handled on an event-basis, instead of being retrieved every interval

-- LOCAL
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local heartbeat = runService.Heartbeat
local Signal = require(script.Parent.Parent.Signal)
local Janitor = require(script.Parent.Parent.Janitor)



-- PUBLIC
local Tracker = {}
Tracker.__index = Tracker
local trackers = {}
Tracker.trackers = trackers
Tracker.itemAdded = Signal.new()
Tracker.itemRemoved = Signal.new()
Tracker.bodyPartsToIgnore = {
	-- We ignore these due to their insignificance (e.g. we ignore the lower and
	-- upper torso because the HumanoidRootPart also covers these areas)
	-- This ultimately reduces the burden on the player region checks
	UpperTorso = true,
	LowerTorso = true,
	Torso = true,
	LeftHand = true,
	RightHand = true,
	LeftFoot = true,
	RightFoot = true,
}



-- FUNCTIONS
function Tracker.getCombinedTotalVolumes()
	local combinedVolume = 0
	for tracker, _ in pairs(trackers) do
		combinedVolume += tracker.totalVolume
	end
	return combinedVolume
end

function Tracker.getCharacterSize(character)
	local head = character and character:FindFirstChild("Head")
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not(hrp and head) then return nil end
	if not head:IsA("BasePart") then
		head = hrp
	end
	local headY = head.Size.Y
	local hrpSize = hrp.Size
	local charSize = (hrpSize * Vector3.new(2, 2, 1)) + Vector3.new(0, headY, 0)
	local charCFrame = hrp.CFrame * CFrame.new(0, headY/2 - hrpSize.Y/2, 0)
	return charSize, charCFrame
end



-- CONSTRUCTOR
function Tracker.new(name)
	local self = {}
	setmetatable(self, Tracker)
	
	self.name = name
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	self.whitelistParams = nil
	self.characters = {}
	self.baseParts = {}
	self.exitDetections = {}
	self.janitor = Janitor.new()

	if name == "player" then
		local function updatePlayerCharacters()
			local characters = {}
			for _, player in pairs(players:GetPlayers()) do
				local character = player.Character
				if character then
					characters[character] = true
				end
			end
			self.characters = characters
		end
		
		local function playerAdded(player)
			local function charAdded(character)
				local humanoid = character:WaitForChild("Humanoid", 3)
				if humanoid then
					updatePlayerCharacters()
					self:update()
					for _, valueInstance in pairs(humanoid:GetChildren()) do
						if valueInstance:IsA("NumberValue") then
							valueInstance.Changed:Connect(function()
								self:update()
							end)
						end
					end
				end
			end
			if player.Character then
				charAdded(player.Character)
			end
			player.CharacterAdded:Connect(charAdded)
			player.CharacterRemoving:Connect(function(removingCharacter)
				self.exitDetections[removingCharacter] = nil
			end)
		end
		
		players.PlayerAdded:Connect(playerAdded)
		for _, player in pairs(players:GetPlayers()) do
			playerAdded(player)
		end
		
		players.PlayerRemoving:Connect(function(player)
			updatePlayerCharacters()
			self:update()
		end)


	elseif name == "item" then
		local function updateItem(itemDetail, newValue)
			if itemDetail.isCharacter then
				self.characters[itemDetail.item] = newValue
			elseif itemDetail.isBasePart then
				self.baseParts[itemDetail.item] = newValue
			end
			self:update()
		end
		Tracker.itemAdded:Connect(function(itemDetail)
			updateItem(itemDetail, true)
		end)
		Tracker.itemRemoved:Connect(function(itemDetail)
			self.exitDetections[itemDetail.item] = nil
			updateItem(itemDetail, nil)
		end)
	end

	trackers[self] = true
	task.defer(self.update, self)
	return self
end



-- METHODS
function Tracker:_preventMultiFrameUpdates(methodName, ...)
	-- This prevents the funtion being called twice within a single frame
	-- If called more than once, the function will initally be delayed again until the next frame, then all others cancelled
	self._preventMultiDetails = self._preventMultiDetails or {}
	local detail = self._preventMultiDetails[methodName]
	if not detail then
		detail = {
			calling = false,
			callsThisFrame = 0,
			updatedThisFrame = false,
		}
		self._preventMultiDetails[methodName] = detail
	end

	detail.callsThisFrame += 1
	if detail.callsThisFrame == 1 then
		local args = table.pack(...)
		task.defer(function()
			local newCallsThisFrame = detail.callsThisFrame
			detail.callsThisFrame = 0
			if newCallsThisFrame > 1 then
				self[methodName](self, unpack(args))
			end
		end)
		return false
	end
	return true
end

function Tracker:update()
	if self:_preventMultiFrameUpdates("update") then
		return
	end
	
	self.totalVolume = 0
	self.parts = {}
	self.partToItem = {}
	self.items = {}
	
	-- This tracks the bodyparts of a character
	for character, _ in pairs(self.characters) do
		local charSize = Tracker.getCharacterSize(character)
		if not charSize then
			continue
		end
		local rSize = charSize
		local charVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += charVolume
		
		local characterJanitor = self.janitor:add(Janitor.new(), "destroy", "trackCharacterParts-"..self.name)
		local function updateTrackerOnParentChanged(instance)
			characterJanitor:add(instance.AncestryChanged:Connect(function()
				if not instance:IsDescendantOf(game) then
					if instance.Parent == nil and characterJanitor ~= nil then
						characterJanitor:destroy()
						characterJanitor = nil
						self:update()
					end
				end
			end), "Disconnect")
		end

		for _, part in pairs(character:GetChildren()) do
			if part:IsA("BasePart") and not Tracker.bodyPartsToIgnore[part.Name] then
				self.partToItem[part] = character
				table.insert(self.parts, part)
				updateTrackerOnParentChanged(part)
			end
		end
		updateTrackerOnParentChanged(character)
		table.insert(self.items, character)
	end

	-- This tracks any additional baseParts
	for additionalPart, _ in pairs(self.baseParts) do
		local rSize = additionalPart.Size
		local partVolume = rSize.X*rSize.Y*rSize.Z
		self.totalVolume += partVolume
		self.partToItem[additionalPart] = additionalPart
		table.insert(self.parts, additionalPart)
		table.insert(self.items, additionalPart)
	end
	
	-- This creates the whitelist so that
	self.whitelistParams = OverlapParams.new()
	self.whitelistParams.FilterType = Enum.RaycastFilterType.Whitelist
	self.whitelistParams.MaxParts = #self.parts
	self.whitelistParams.FilterDescendantsInstances = self.parts
end



return Tracker]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX667AE447ADE44527BC488DC823CAD2CF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ZonePlusReference</string>
							<string name="ScriptGuid">{44619CC1-8581-41FA-B4A9-8AB5FD868A6A}</string>
							<ProtectedString name="Source"><![CDATA[-- This module enables you to place Zone wherever you like within the data model while
-- still enabling third-party applications (such as HDAdmin/Nanoblox) to locate it
-- This is necessary to prevent two ZonePlus applications initiating at runtime which would
-- diminish it's overall efficiency

local replicatedStorage = game:GetService("ReplicatedStorage")
local ZonePlusReference = {}

function ZonePlusReference.addToReplicatedStorage()
    local existingItem = replicatedStorage:FindFirstChild(script.Name)
    if existingItem then
        return false
    end
    local objectValue = Instance.new("ObjectValue")
    objectValue.Name = script.Name
    objectValue.Value = script.Parent
    objectValue.Parent = replicatedStorage
    local locationValue = Instance.new("BoolValue")
    locationValue.Name = (game:GetService("RunService"):IsClient() and "Client") or "Server"
    locationValue.Value = true
    locationValue.Parent = objectValue
    return objectValue
end

function ZonePlusReference.getObject()
    local objectValue = replicatedStorage:FindFirstChild(script.Name)
    if objectValue then
        return objectValue
    end
    return false
end

return ZonePlusReference]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXA7F6A7F90A8E4306BB2F229B690B5850">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LibraryHandler</string>
					<string name="ScriptGuid">{F67C53DD-BBB5-4643-B236-5BF9A7A82C6E}</string>
					<ProtectedString name="Source"><![CDATA[local Library = script.Parent.Library
local OmegaNum = require(Library.OmegaNum)
local EternityNum2 = require(Library.EternityNum)
local BigNum = require(Library.Bnum)
local NumberV3 = require(Library.Number)

local LibraryFormat = {}

function LibraryFormat.Setup(val, library, setting: 'No'|'Yes')
    if library == 'OmegaNum' then
        return OmegaNum.short(val)
    elseif library == 'EternityNum2' then
        return EternityNum2.short(val)
    elseif library == 'BigNum' then
        return BigNum.short(val)
    elseif library == 'NumberV3' then
        return NumberV3.short(val, setting)
    end
end

function LibraryFormat.short(val, library: 'OmegaNum'|'EternityNum2'|'BigNum'|'NumberV3', setting: 'No'|'Yes')
    return LibraryFormat.Setup(val, library, setting)
end

return LibraryFormat]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX67783748CC1C4EBEA9E889CBF127721B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayersData</string>
					<string name="ScriptGuid">{859C9E63-B061-4B09-B0F2-0E600721893F}</string>
					<ProtectedString name="Source"><![CDATA[export type Data = {
    MainData: {
        NumberValue: {},
        IntValue: {},
        StringValue: {},
        BoolValue: {},
    },   
    PlusData: {
        NumberValue: {},
        IntValue: {},
        StringValue: {},
        BoolValue: {},
    },
    CostData: {
        NumberValue: {},
        IntValue: {},
        StringValue: {},
        BoolValue: {},
    },
    BoolData: {
        NumberValue: {},
        IntValue: {},
        StringValue: {},
        BoolValue: {},
    },
    leaderstats: {
        NumberValue: {},
        IntValue: {},
        StringValue: {},
        BoolValue: {},
    },
    Stats: {
        NumberValue: {},
        IntValue: {},
        StringValue: {},
        BoolValue: {},
    },
    AttributeData: {}
}

local PlayersData: Data = {
    --[[ example for Folder.Data
        MainData = {
            NumberValue = {
                Cash = 0
            }
        }
    ]]
    --[[ example for AttributeData
        AttributeData = {
            Cash = 0
        }
    ]]
    --[[ example for Table Data 
        Cash = 0
    ]]
    --[[MainData = {
        NumberValue = {
            Cash = {
                MainValue = 0,
                MaxUpgrades = 10,
                Upgrade = 0,
                IsUpgradable = true
            }
        }
    }
]]
    leaderstats = {
        NumberValue = {
            Cash = 0,
        }
    }
}

return PlayersData]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA0ABFE8D6C914D8FBA5368B358B83FAA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Session</string>
					<string name="ScriptGuid">{C9A3BC3E-A0A6-40C0-A8A2-7C9A92B6824C}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
module.Session = {}
return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXEABA72F4060447778761A50F4036C3C7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GetData</string>
					<string name="ScriptGuid">{9486EE7C-E10E-4E79-A254-9E38D218A34F}</string>
					<ProtectedString name="Source"><![CDATA[local EventManager = {}
local Modules = script.Parent
local playersData = require(Modules.Session)

function GetDataFolder(player, folderName, valType)
    local data = playersData.Session[player.UserId][folderName]
    local val = data[valType]
    return val
end

function GetDataAttribute(player, attribute)
    local data = playersData.Session[player.UserId]
    return data[attribute]
end

function GetDataTable(player, valueName)
    local data = playersData.Session[player.UserId]
    return data[valueName]
end

function EventManager.RENum(player, folder, typeData: 'Value'|'Attribute'|'Table')
    local val
    if typeData == 'Value' then
        val = GetDataFolder(player, folder, 'NumberValue')
    elseif typeData == 'Attribute' then
        val = GetDataAttribute(player, folder)
    elseif typeData == 'Table' then
        val = GetDataTable(player, folder)
    end
    return val
end

function EventManager.REStr(player, folder, typeData: 'Value'|'Attribute'|'Table')
    local val
    if typeData == 'Value' then
        val = GetDataFolder(player, folder, 'StringValue')
    elseif typeData == 'Attribute' then
        val = GetDataAttribute(player, folder)
    elseif typeData == 'Table' then
        val = GetDataTable(player, folder)
    end
    return val
end

function EventManager.REBol(player, folder, typeData: 'Value'|'Attribute'|'Table')
    local val
    if typeData == 'Value' then
        val = GetDataFolder(player, folder, 'BoolValue')
    elseif typeData == 'Attribute' then
        val = GetDataAttribute(player, folder)
    elseif typeData == 'Table' then
        val = GetDataTable(player, folder)
    end
    return val
end

function EventManager.REInt(player, folder, typeData: 'Value'|'Attribute'|'Table')
    local val
    if typeData == 'Value' then
        val = GetDataFolder(player, folder, 'IntValue')
    elseif typeData == 'Attribute' then
        val = GetDataAttribute(player, folder)
    elseif typeData == 'Table' then
        val = GetDataTable(player, folder)
    end
    return val
end

return EventManager]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBBAA7AA9751F4EDF81C63B83B2CDE494">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Zone</string>
					<string name="ScriptGuid">{2CF600F9-CB00-4A28-B063-088261277E95}</string>
					<ProtectedString name="Source"><![CDATA[local ZoneManager = {}
local workSpace = workspace

function ZoneManager.CreateZone(basePart: string, playerModule, zonePlus, waitTime, func: (player: Player, playerLoops: {boolean}, timeEntered: number) -> Player)
    local model = workSpace:FindFirstChild(basePart)
    model.CanCollide = false
    model.Anchored = true
    local zone = zonePlus.new(model)
    local checker = playerModule.ZoneChecker
    zone.playerEntered:Connect(function(player)
        table.insert(playerModule.Player, player)
        checker[player.UserId] = true
        return func(player, checker, waitTime)
    end)
    zone.playerExited:Connect(function(player)
        local findPlayer = table.find(playerModule.Player, player)
        checker[player.UserId] = false
        table.remove(playerModule.Player, findPlayer)
    end)
end

function ZoneManager.FindFolder(folderName: string)
    local folder = workSpace:FindFirstChild(folderName)
    return folderName
end

function ZoneManager.CreateZoneFromFolder(folderName, basePart: string, playerModule, zonePlus, waitTime: number, func: (player: Player, playerLoops: {boolean}, timeEntered: number) -> Player)
    local folderModule = ZoneManager.FindFolder(folderName)
    local model = folderModule:FindFirstChild(basePart)
    model.CanCollide = false
    model.Anchored = true
    local zone = zonePlus.new(model)
    local checker = playerModule.ZoneChecker
    zone.playerEntered:Connect(function(player)
        table.insert(playerModule.Player, player)
        checker[player.UserId] = true
        return func(player, checker, waitTime)
    end)
    zone.playerExited:Connect(function(player)
        local findPlayer = table.find(playerModule.Player, player)
        checker[player.UserId] = false
        table.remove(playerModule.Player, findPlayer)
    end)
end

return ZoneManager]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA0A59B85125447BDB709271FF70E34EC">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">TouchedEvent</string>
					<string name="ScriptGuid">{D7656BCB-C113-4139-B230-B54A32232A27}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
local work = workspace

function module.Touched(part: string, func)
    local model
    model = work:FindFirstChild(part)
    if not model then
        model = work:FindFirstChild(part)
    end
    model.Touched:Connect(func)
end

function module.TouchEnded(part: string, func)
    local model
    model = work:FindFirstChild(part)
    if not model then
        model = work:FindFirstChild(part)
    end
    model.TouchEnded:Connect(func)
end

function module.GetFold(folderName)
    local folder = work:FindFirstChild(folderName)
    return folder
end

function module.Get2ndFolder(folderName, folder2Name)
    local getFolder1 = module.GetFold(folderName)
    local folder2 = getFolder1:FindFirstChild(folder2Name)
    return folder2
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX5697108F72A9464CA09EF01656CD83F7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerModule</string>
					<string name="ScriptGuid">{72FBF17C-2FA7-4408-B292-A29898ABD3EA}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

module.Player = {}
module.ZoneChecker = {}

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX7FE25EFC356C4CA890290CE9ECB9B34D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GetEvents</string>
					<string name="ScriptGuid">{4EDC2038-9DA8-4CE4-8649-307EC0D8EC21}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}
local ReplicatedStorage = game:GetService('ReplicatedStorage')

function module.GetRE(getREName: string, func: (player: Player) -> Player): 'RemoteEvent Under ReplicatedStorage'
    local event = ReplicatedStorage:FindFirstChild(getREName)
    event.OnServerEvent:Connect(func)
    return event
end

function module.GetREFold(fold: string, getREName: string, func: (player: Player) -> Player): 'RemoteEvent Under ReplicatedStorage.FolderName'
    local event = ReplicatedStorage:FindFirstChild(fold):FindFirstChild(getREName)
    event.OnServerEvent:Connect(func)
    return event
end

function module.GetRF(getRFName: string, func: (player: Player) -> Player): 'RemoteFunction Under ReplicatedStorage'
    local RF = ReplicatedStorage:FindFirstChild(getRFName)
    if not RF then 
        RF = Instance.new('RemoteFunction')
        RF.Name = getRFName
        RF.Parent = ReplicatedStorage
    end
    RF.OnServerInvoke = func
    return RF
end

function module.GetRFFold(fold: string, getRFName: string, func: (player: Player) -> Player): 'RemoteFunction Under ReplicatedStorage.FolderName'
    local RF = ReplicatedStorage:FindFirstChild(fold):FindFirstChild(getRFName)
    RF.OnServerInvoke = func
    return RF
end

return module
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6CAEC8972B5640308D35332A1F2AFCC6">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Scripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Script" referent="RBXD5DBDA4D8F4F4D5797F040BCECD10EFF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">MainDataStore</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{4B264312-4DE5-4BA4-A67B-B5F71FA6FD6C}</string>
					<ProtectedString name="Source"><![CDATA[local Scripts = script.Parent
local DataStoreV5 = Scripts.Parent
local Modules = DataStoreV5.Modules
local DataStoreModule = require(Modules.DataStoreManager)
local PlayersData = require(Modules.PlayersData)
local DataService = game:GetService('DataStoreService')
local DataStore = DataStoreModule.CreateDataStore(DataService, 'PlayersData', PlayersData, 'Value')
--[[ ValueData
local DataStore = DataStoreModule.CreateDataStore(DataStoreModule.DataService, 'PlayersData', PlayersData, 'Value')
]]
--[[ TableData
local DataStore = DataStoreModule.CreateDataStore(DataStoreModule.DataService, 'TableData', PlayersData, 'Table')
]]
--[[ AttributeData
local DataStore = DataStoreModule.CreateDataStore(DataStoreModule.DataSerivce, 'AttributeData', PlayersData, 'Attribute')
]]
--[[ ValueAttribute
local DataStore = DataStoreModule.CreateDataStore(DataStoreModule.DataSerivce, 'ValueAttributeData1', PlayersData, 'ValueAttribute')
]]
local RunService = game:GetService('RunService')
local Players = game:GetService('Players')

function PlayerJoined(player)
    return DataStore:GetAsync(player)
--[[
    Folder Attribute option
    DataStore:GetAsync(player, 'MainData', 'Folder')
    ]]
end

function PlayerLeaving(player)
    return DataStore:UpdateAsync(player)
end

Players.PlayerAdded:Connect(PlayerJoined)
Players.PlayerRemoving:Connect(PlayerLeaving)

game:BindToClose(function()  return DataStore:BindClose(RunService, Players) end)
DataStore:AutoSave(Players)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBXBBABEF3735E24C9AB741199420B868C6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WorkspaceManagement</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{4E062864-5A20-42F0-B131-DC10D1C1F708}</string>
					<ProtectedString name="Source"><![CDATA[local Scripts = script.Parent
local DataStoreV5 = Scripts.Parent
local Modules = DataStoreV5.Modules
local EventManager = require(Modules.GetData)
local TouchedEvent = require(Modules.TouchedEvent)
local Players = game:GetService('Players')
local ZonePlusManager = require(Modules.Zone)
local ZonePlus = require(Modules.Library.Zone)
local PlayerModule = require(Modules.PlayerModule)

--[[ example for controlling a Zone to print a player Name or to add new Data
ZonePlusManager.CreateZone('Container', PlayerModule, ZonePlus, 0.5, function(player, playerLoops, timeEntered)
    local loopRun = true
    local ls = player:FindFirstChild('leaderstats')
    local Cash = ls:FindFirstChild('Cash')
    local lsData = GetData.Num(player, ls.Name)
    local success, err
    local loopFunc = function()
        repeat
            success, err = pcall(function()
                print(player.Name, 'Has entered the Zone')
                Cash.Value = Cash.Value + 1
                lsData[Cash.Name] = Cash.Value
            end)
            task.wait(timeEntered)
        until not loopRun or not playerLoops[player.UserId] or not (player.Parent == game.Players)
        if not success then
            warn('Loop error')
        end
    end
    task.spawn(loopFunc)
    if success then
        warn('Working')
    end
end)
]]
--[[ example
TouchedEvent.Touched('Ray', function(model)
    local character = model.Parent
    if character:FindFirstChild('Humanoid') then
        local player = Players:GetPlayerFromCharacter(character)
        local ls = player:FindFirstChild('leaderstats')
        local Cash = ls:FindFirstChild('Cash')
        local CashPlus = ls:FindFirstChild('CashPlus')
        local lsData = GetData.Num(player, ls.Name)
        Cash.Value = Cash.Value + CashPlus.Value
        lsData[Cash.Name] = Cash.Value
        print(player.Name)
    end
end)
]]]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX52B0BCCE290748829887070D145E1546">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RemoteManager</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{75954894-956A-42EA-826C-664461B0F799}</string>
					<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Scripts = script.Parent
local DataStoreV5 = Scripts.Parent
local Modules = DataStoreV5.Modules
local EventManager = require(Modules.GetData)
local GetEvents = require(Modules.GetEvents)
local Number = require(Modules.Library.Number)

--[[ example for Attribute Data
GetEvents.GetRF('Cash', function(player)
    local data = EventManager.RENum(player, 'AttributeData', 'Attribute')
    data['Cash'] = player:GetAttribute('Cash') + player:GetAttribute('CashPlus')
    player:SetAttribute('Cash', data['Cash'])
    ReplicatedStorage:FindFirstChild('Cash'):InvokeClient(player, data['Cash'])
end)]]

--[[ example
GetEvents.GetRE('RemoteEvent', function(player)
    local ls = player:FindFirstChild('leaderstats')
    local Cash = ls:FindFirstChild('Cash')
    local data = EventManager.RENum(player, ls.Name)
    local CashPlus = ls:FindFirstChild('CashPlus')
    Cash.Value = Cash.Value + CashPlus.Value
    data[Cash.Name] = Cash.Value
end)
]]]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="ModuleScript" referent="RBX50B1894E4A684D4793CE20D167FE6E61">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Read Only</string>
				<string name="ScriptGuid">{66BD3587-6877-49DB-81B8-F64A39FCD9A0}</string>
				<ProtectedString name="Source"><![CDATA[--[[
Final DataStore Edition but made by Taylow220
Release Version 1.0

Pre-set Data Example is in Modules.PlayersData
Pre-set DataName in Scripts on line 8 -- [
    how to change it is change Value to ValueAttribute to create Values with Attribute,
    DataStore = DataStore(DataStoreModule.DataSerivce, 'InterChangable', PlayersData, 'ValueAttribute')
    example Data = [ auto setup Folder.Value.Settings
    PlayersData = {
        MainData = {
            NumberValue = {
                Cash = {
                    MainValue = 0 -- MainValue sets up the Cash.Value = 0
                }
            }
        }
    }
    ]
    
    Table to create a table Data then create the Folder and instances
    DataStore = DataStore(DataStoreModule.DataSerivce, 'InterChangable', PlayersData, 'Table')
    example Data = [ you would have to manually setup the Folder and Values
    PlayersData = {
        Cash = 0,
    }
    ]
    
    Attribute is setting up Attribute to Player or option 2 is to a Folder
    DataStore = DataStore(DataStoreModule.DataService, 'InterChangeable', PlayersData, 'Attribute')
    example Data = [ creates the Data to player
    PlayersData = {
        AttributeData = {
            Cash = 0
        }
    }
    ]
    
    Value is to create Folder with Value automatically like Preset Data
    DataStore = DataStore(DataStoreModule.DataSerivce, 'InterChangable', PlayersData, 'Value')
    example Data = [ auto creates Folder and Value
    PlayersData ={
        MainData = {
            NumberValue = {
                Cash = 0
            }
        }
    }
    ]
]
]]]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>